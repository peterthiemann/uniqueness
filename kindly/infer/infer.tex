\section{Inference}

An important innovation of \affe is its principal type inference.
We now formulate our inference algorithm
based on the HM(X) framework~\citep{DBLP:journals/tapos/OderskySW99}.
HM(X) presents how to implement Hindley-Milner type inference in a language
with qualified types and an arbitrary custom constraint language.
We adapt and extend the rules of HM(X) to support kind inference,
track linearity and handle borrows and regions. Furthermore, we
formulate an appropriate constraint solving algorithm for our constraint
system such that inference is sound and complete.
In addition, our constraint solving algorithm simplifies constraints in a
principled way.
We first present various preliminary definitions
before showing our kind and type inference judgements
and our constraint solving algorithm.

\subsection{Preliminaries}

Unlike the syntax-directed version of our type system, knowing which elements
are input and output or our inference judgement is critical. In the rest
of this section, when presenting a new judgement
we will note in \textbf{bold} the input parameters. The rest will then be
output parameters.

\subsubsection{Usage environments}

% One novelty of our inference  judgement now
% returns a type environment, which we call ``usage environment'' and commonly
% note $\Sv$, to summarize how variables and borrows are used inside
% the expression.

In order to determine if a variable is used in an affine manner, we must track
its uses and the associated kinds. For instance, in the expression
$(x,x)$, $x$ is used twice. If $x$ is of type $\tau$, which is of kind $k$,
we must add the constraint $\Cleq{k}{\kun}$.
%
In order to infer such constraints, our inference judgement will not only
take an environment as parameter but also return an environment, which
we call ``usage environment'', and which summarize how variables and borrows
are used. Usage environments follow the exact same grammar
as normal environment. In order to distinguish them more easily,
we will general note them $\Sv$.

In \cref{sdtyping}, we used various relations to split environments in two, or
transform suspended bindings into borrow binding inside an environment.
These relations took as argument a constraint which is used to validate
the environment transformation.
In the context of inference, we define a new judgements which \emph{infers}
the constraints required.
\begin{itemize}
\item $\bsplit{C}{\Sv}{\bf{\Sv_1}}{\bf{\Sv_2}}$.
  Given two usage environments (inferred for two subexpressions, for instance)
  $\Sv_1$ and $\Sv_2$, we return $\Sv$, the merged environment, and $C$, a set
  of constraints that must be respected.
  This relation is total and non-ambiguous given $\Sv_1$ and $\Sv_2$
  and uses the same rules as the one presented in \cref{sdtyping:split}.
\item $\bregion{C}{\bf{x}}{\Sv}{\bf\Sv'}$.
  Given a usage environment $\Sv'$ and a variable name $x$, we return
  $\Sv$ where the borrow binding of $x$ in $\Sv'$, if it exists, is replaced by
  a suspended binding. We also return $C$, a set of constraints that must
  be respected.
  Again, the relation is total and non-ambiguous for any given $\Sv'$ and $x$,
  and uses the same rules as the one presented in \cref{sdtyping:regions}.
\end{itemize}

The relations used for syntax-directed typing can trivially be defined
in term of these new relations and constraint entailment.
All relations are fully described in \cref{typ:extra:envs}.

\subsubsection{Constraint normalization}

The HM(X) framework assumes the existence of a $\operatorname{normalize}$
function which takes a constraint $C$ and a substitution $\psi$ and returns a
simplified constraint $C'$,
and an updated substitution $\unif'$.
Normalization is supposed to return the ``best'' solution $(C',\unif')$, for
instance the most general unifier.
We detail the implementation
of the normalization function and its property in \cref{infer:solving}.
In the meantime, we simply
assume the existence of such a function for our constraint system.

\subsection{Kind inference}

We note $\inferK{(C,\unif)}{\bf{\E}}{\bf{\tau}}{k}$ when type $\tau$ has kind $k$
in environment $\E$ under constraints $C$ and unifier $\unif$.
$\E$ and $\tau$ are the input parameters of
our inference procedure.
We present the kind inference algorithm as a set of rules in
\cref{rules:kinding}.
Similar to the syntax-directed rules, higher-kinds are not generally supported
and can only appear by looking-up the kind scheme of a type constructor,
for use in the type application rule {\sc KApp}.
Type variables must be of a simple kind in rule {\sc KVar}.
Kind schemes are instantiated in the {\sc KVar} rules by creating
fresh kind variables and the associated substitution.
{\sc KArr} and {\sc KBorrow} simply returns the kind of the primitive
arrow and borrow types.
The $\operatorname{normalize}$ function is used every time several constraints
must be composed in order to simplify the constraint and return a most general
unifier.

\begin{figure}[ht]
  \centering
  \input{infer/kinds}
  \caption{Kind inference algorithm -- $\inferK{(C,\unif)}{\E}{\tau}{k}$}
  \label{rules:kinding}
\end{figure}



\subsection{Type inference}

We note $\inferW{\Sv}{(C,\unif)}{\bf{\E}}{\bf{e}}{\tau}$ when
$e$\ has type $\tau$ in $\E$ under the constraints $C$ and unifier $\unif$
with a usage environment $\Sv$. $\E$ and $e$ are the input parameters of our
inference algorithm.
The rules are shown in \cref{rules:typing}.

\TODO{Explain/Cut}

\subsubsection{Environments and bindings}
\label{infer:envs}

\begin{figure}[!h]
  \begin{mathpar}
    { \Weaken_{\bvar{x}{\sigma}}(\Sv) =
      \begin{dcases}
        \Ctrue&\text{if } x\in\Sv\\
        \Cleq{\sigma}{\kaff_\infty}&\\
      \end{dcases}
    }
    \and
    \ruleIVar
    \and
    \ruleIAbs
  \end{mathpar}
  \caption{The {\sc Abs$_I$} and {\sc Var$_I$} rules}
  \label{rule:infer:envs}
\end{figure}


\subsubsection{Copying and Splitting}
\label{infer:split}

\begin{figure}[!h]
  \centering
  \begin{mathpar}
    \ruleIPair
  \end{mathpar}
  \caption{The {\sc Pair$_I$} rule}
  \label{rule:infer:pair}
\end{figure}

\subsubsection{Regions}
\label{infer:regions}


\begin{figure}[!h]
  \centering
  \begin{mathpar}
    \ruleIRegion
  \end{mathpar}
  \caption{The {\sc Region$_I$} rule}
  \label{rule:infer:region}
\end{figure}

\subsubsection{Constraint desugaring}

\begin{figure}[!htb]
  \begin{mathpar}

  \inferrule{}{ \Cleq{\Eempty}{k} \Crewrite  \Cempty}

  \inferrule{
    \Cleq\E k \Crewrite  C \\ \E \vdash \Cleq B k \Crewrite  D
  }{
    \Cleq{\E; B}{k} \Crewrite  C \Cand D
  }

  \inferrule{
    \E \vdash \Cleq \schm k \Crewrite  C
  }{ \E \vdash \Cleq{\bvar x \schm}{k} \Crewrite  C}

  \inferrule{ }{
    \E \vdash \Cleq{\svar x \schm^n} k \Crewrite  \Cfalse
  }

  % \inferrule{}{\Cleq{\IBORROW^n} k \Crewrite  \Cleq{\kun_n} k}

  % \inferrule{}{\Cleq{\MBORROW^n} k \Crewrite  \Cleq{\kaff_n} k}

    \inferrule{
      \inferK{C \Cand C_x} \E \tau {k'} \\
      D = C \Cand C_x \Cand \Cleq{k'}k
    }{
      \E \vdash
      \Cleq{(\forall \kvar_i \forall (\tvar_j:k_j).\ \qual{C_x}{\tau})}{k} \Crewrite  D
    }
  \end{mathpar}

  \caption{Rewriting constraints on environments and types}
  \label{rule:typing:desugar}
\end{figure}

\subsection{Constraint solving}
\label{infer:solving}

\TODO{Present the full constraint system}

We now place ourselves in a more general context where kinds are either variables
or constants belonging to a total bounded lattice $(\mathcal L, \lk_\Lat)$ ie.,
a lattice which admits a total order and upper and lower bounds ($l^\top$ and $l^\bot$).
We note lattice elements $l$ and $\glb_i l_i$ (resp. $\lub_i l_i$)
the greatest lower bound (resp. least upper bound) in $\mathcal L$.
%
Let $\CL$ the set of constraints in this lattice. We consider the
following base entailment rules in this system:
\begin{center}
  \begin{mathpar}
    \inferrule{l \lk_\Lat l'}{\entail{}{\Cleq{l}{l'}}}
    \and
    \inferrule{}{\entail{}{\Cleq{k}{l^\top}}}
    \and
    \inferrule{}{\entail{}{\Cleq{l^\bot}{k}}}
  \end{mathpar}
\end{center}



The normalization procedure is noted $\normalize{C_0}{\unif_0}$ where
$C_0\in \CL$ is a set of constraints and $\unif_0$ is a substitution.
It returns a constraint $C \in \mathcal S$ in
solved form and a unifier $\unif$.
The main idea of the algorithm is to first remove all the type equalities
by using regular Herbrand unification. After that, we only have
a set of inequalities among kinds, which we can consider as a relation.
We can then saturate the relation,
unify all kinds that are in the same equivalence classes to obtain
a most general unifier on kind variables,
remove all existentially quantified variables and
then minimize back the relation and apply various
simplification rules to make the resulting type easier to understand to users.

More precisely, we apply the following steps:
\begin{enumerate}
\item Solve all type equality constraints through Herband unification and
  gather all existential quantifications at the front of the constraint.
  We obtain a constraint $C^k = \exists \kvar_i,\ \Cleq{k_j}{k'_j}_j$ and
  a substitution $\unif_\tau$.
  
  We note $\mathcal R$ the relation $\Cleq{k_j}{k'_j}_j$,
  $\mathcal G$ the underlying directed graph and $V$ its vertices.

\item Saturate the lattice equalities in $\mathcal R$.
  
  More precisely, for each kind variable $\kvar \in V$,
  for each constant $l_i$ (resp. $l_j$) such that
  there is a path from $l_i$ to $\kvar$ (resp. from $\kvar$ to $l_j$) in $\mathcal G$,
  add an edge from $\lub l_i$ to $\kvar$
  (resp. from $\kvar$ to $\glb l_j$).
  This step is well defined since $\mathcal L$ is a bounded lattice
  and $\lub\emptyset$ and $\glb\emptyset$ are well defined.

  We also complement $\mathcal R$ with $(\leq)$ by adding an edge
  between related constants.
\item
  At this point, we can easily check for satisfiability: A constraint
  is satisfiable (in the given environment) if and only if,
  for any constants $l_1$ and $l_2$ such that
  there is a path from $l_1$ to $l_2$ in $\mathcal G$, then $l_1\lk_\Lat l_2$.
  If this is not the case, we return \textbf{fail}.
  
\item For each strongly connected component in $\mathcal G$, unify all its vertices and replace it by a representative.
  We note $\unif_k$ the substitution that replaces a kind variable by
  its representative.
  The representative of a strongly connected component $g$ can be determined as follows:
  \begin{itemize}
  \item If $g$ does not contain any constant, then the representative
    is a fresh kind variable.
  \item If $g$ contains exactly one constant, it is the representative.
  \item Otherwise, the initial constraint $C_0$ is not satisfiable.
  \end{itemize}
  Note that this step will also detect all unsatisfiable constraints.
\item Take the transitive closure of $\mathcal R$.
\item Remove all the vertices corresponding to the kind variables $\kvar_i$
  that are existentially quantified in $C^k$.
\item Take the transitive reduction of $\mathcal R$.
\item Remove the extremums of $\mathcal L$ and the edges of $(\leq)$
  from $\mathcal R$.
\item Return $C = \left\{ k \leq k' \mid k \operatorname{\mathcal R}k' \right\}$
  and $\unif =  \unif_\tau \meet \unif_k$.
\end{enumerate}

\TODO{Add an example}

\subsection{Soundness and Principality}

Our system is an extension of HM(X). Our goal is prove soundness and completeness
of our inference algorithm with respect to our syntax-directed system, which
assures us principal type inference.
We prove two properties:
\begin{itemize}
\item Our constraint system respects all the properties required by HM(X)
  for principal type inference.
\item Our extended inference algorithm still satisfies the soundness
  and completeness properties of HM(X). This is achieved by extending
  the original proofs.
\end{itemize}

\TODO{State the theorems}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
