\section{Inference}

We now formulate type inference for \lang. Type inference is
based on the HM(X) framework~\citep{DBLP:journals/tapos/OderskySW99} which
presents how to implement Hindley-Milner type inference in a language
with qualified types and an arbitrary custom constraint language.
We adapt and extend the rules of HM(X) to support kind inference,
track linearity and affinity and handle borrow and regions. Furthermore, we
formulate an appropriate constraint solving algorithm for our constraint
system such that inference is sound and complete.
In the rest of this section, we first present various preliminaries definitions
before showing our kind and type inference judgements
and our constraint solving algorithm.

\subsection{Preliminaries}

Unlike the syntax-directed version of our type system, knowing which elements
are input and output or our inference judgement is critical. In the rest
of this section, when presenting a new judgement
we will note in \textbf{bold} the input parameters. The rest will then be
output parameters.

\subsubsection{Usage environments}

% One novelty of our inference  judgement now
% returns a type environment, which we call ``usage environment'' and commonly
% note $\Sv$, to summarize how variables and borrows are used inside
% the expression.

In order to determine if a variable is used in an affine manner, we must track
its uses and the associated kinds. For instance, in the expression
$(x,x)$, $x$ is used twice. If $x$ is of type $\tau$, which is of kind $k$,
we must add the constraint $\Cleq{k}{\kun}$.
%
In order to infer such constraints, our inference judgement will not only
take an environment as parameter but also return an environment, which
we call ``usage environment'', and which summarize how variables and borrows
are used. Usage environments follow the exact same grammar
as normal environment. In order to distinguish them more easily,
we will general note them $\Sv$.

In \cref{sdtyping}, we used various relations to split environments in two, or
transform suspended bindings into borrow binding inside an environment.
These relations took as argument a constraint which is used to validate
the environment transformation.
In the context of inference, we define a new judgements which \emph{infers}
the constraints required.
\begin{itemize}
\item $\bsplit{C}{\Sv}{\bf{\Sv_1}}{\bf{\Sv_2}}$.
  Given two usage environments (inferred for two subexpressions, for instance)
  $\Sv_1$ and $\Sv_2$, we return $\Sv$, the merged environment, and $C$, a set
  of constraints that must be respected.
  This relation is total and non-ambiguous given $\Sv_1$ and $\Sv_2$
  and uses the same rules as the one presented in \cref{sdtyping:split}.
\item $\bregion{C}{\bf{x}}{\Sv}{\bf\Sv'}$.
  Given a usage environment $\Sv'$ and a variable name $x$, we return
  $\Sv$ where the borrow binding of $x$ in $\Sv'$, if it exists, is replaced by
  a suspended binding. We also return $C$, a set of constraints that must
  be respected.
  Again, the relation is total and non-ambiguous for any given $\Sv'$ and $x$,
  and uses the same rules as the one presented in \cref{sdtyping:regions}.
\end{itemize}

The relations used for syntax-directed typing can trivially be defined
in term of these new relations and constraint entailment.
All relations are fully described in \cref{typ:extra:envs}.

\subsubsection{Constraint normalization}

The HM(X) framework assumes the existence of a $\operatorname{normalize}$
function which takes a constraint $C$ and a substitution $\psi$ and returns a
constraint in solved form $C'$,
and an updated substitution $\unif'$.
Normalization is supposed to return the ``best'' solution $(C',\unif')$, for
instance the most general unifier.
We detail the implementation
of the normalization function in \cref{infer:solving}. In the meantime, we just
assume the existence of such a function for our constraint system.

\subsection{Kind inference}

We note $\inferK{(C,\unif)}{\bf{\E}}{\bf{\tau}}{k}$ when type $\tau$ has kind $k$
in environment $\E$ under constraints $C$ and unifier $\unif$.
$\E$ and $\tau$ are the input parameters of
our inference procedure.
We present the kind inference algorithm as a set of rules in
\cref{rules:kinding}.
Similar to the syntax-directed rules, higher-kinds are not generally supported
and can only appear by looking-up the kind scheme of a type constructor,
for use in the type application rule {\sc KApp}.
Type variables must be of a simple kind in rule {\sc KVar}.
Kind schemes are instantiated in the {\sc KVar} rules by creating
fresh kind variables and the associated substitution.
{\sc KArr} and {\sc KBorrow} simply returns the kind of the primitive
arrow and borrow types.
The $\operatorname{normalize}$ function is used every time several constraints
must be composed in order to simplify the constraint and return a most general
unifier.

\begin{figure}[ht]
  \centering
  \input{infer/kinds}
  \caption{Kind inference algorithm -- $\inferK{(C,\unif)}{\E}{\tau}{k}$}
  \label{rules:kinding}
\end{figure}



\subsection{Type inference}

We note $\inferW{\Sv}{(C,\unif)}{\bf{\E}}{\bf{e}}{\tau}$ when
$e$\ has type $\tau$ in $\E$ under the constraints $C$ and unifier $\unif$
with a usage environment $\Sv$. $\E$ and $e$ are the input parameters of our
inference algorithm.
The rules are shown in \cref{rules:typing}.

\TODO{Explain/Cut}

\begin{figure*}[htp]
  \input{infer/typing}
  \caption{Type inference algorithm -- $\inferW{\Sigma}{(C,\psi)}{\bf{\E}}{\bf{e}}{\tau}$ }
  \label{rules:typing}
\end{figure*}

\begin{figure}[tp]
  \centering
  \begin{mathpar}
    { \Weaken_{\bvar{x}{\sigma}}(\Sv) =
      \begin{dcases}
        \Ctrue& \text{if } x\in\Sv\\
        \Cleq{\sigma}{\kaff_\infty}&\\
      \end{dcases}
    }

    \inferrule{
      \inferK{C \Cand C_x} \E \tau {k'} \\
      D = C \Cand C_x \Cand \Cleq{k'}k
    }{
      \E \vdash \Cleq{\forall \kvar_i \forall (\tvar_j:k_j).\ \qual{C_x}{\tau}}{k} \Crewrite  D
    }
  \end{mathpar}
  \caption{Auxiliary rules for inference}
  \label{op:usgmap}
\end{figure}

\subsection{Constraint solving}
\label{infer:solving}

\TODO{Present the full constraint system}

We now place ourselves in a more general context where kinds are either variables
or constants belonging to a total bounded lattice $(\mathcal L, \lk_\Lat)$ ie.,
a lattice which admits a total order and upper and lower bounds ($l^\top$ and $l^\bot$).
We note lattice elements $l$ and $\glb_i l_i$ (resp. $\lub_i l_i$)
the greatest lower bound (resp. least upper bound) in $\mathcal L$.
%
Let $\CL$ the set of constraints in this lattice. We consider the
following base entailment rules in this system:
\begin{center}
  \begin{mathpar}
    \inferrule{l \lk_\Lat l'}{\entail{}{\Cleq{l}{l'}}}
    \and
    \inferrule{}{\entail{}{\Cleq{k}{l^\top}}}
    \and
    \inferrule{}{\entail{}{\Cleq{l^\bot}{k}}}
  \end{mathpar}
\end{center}



The normalization procedure is noted $\normalize{C_0}{\unif_0}$ where
$C_0\in \CL$ is a set of constraints and $\unif_0$ is a substitution.
It returns a constraint $C \in \mathcal S$ in
solved form and a unifier $\unif$.
The main idea of the algorithm is to first remove all the type equalities
by using regular Herbrand unification. After that, we only have
a set of inequalities among kinds, which we can consider as a relation.
We can then saturate the relation,
unify all kinds that are in the same equivalence classes to obtain
a most general unifier on kind variables,
remove all existentially quantified variables and
then minimize back the relation.

More precisely, we apply the following steps:
\begin{enumerate}
\item Solve all type equality constraints through Herband unification and
  gather all existential quantifications at the front of the constraint.
  We obtain a constraint $C^k = \exists \kvar_i,\ \Cleq{k_j}{k'_j}_j$ and
  a substitution $\unif_\tau$.
  
  We note $\mathcal R$ the relation $\Cleq{k_j}{k'_j}_j$,
  $\mathcal G$ the underlying directed graph and $V$ its vertices.

\item Saturate the lattice equalities in $\mathcal R$.
  
  More precisely, for each kind variable $\kvar \in V$,
  for each constant $l_i$ (resp. $l_j$) such that
  there is a path from $l_i$ to $\kvar$ (resp. from $\kvar$ to $l_j$) in $\mathcal G$,
  add an edge from $\lub l_i$ to $\kvar$
  (resp. from $\kvar$ to $\glb l_j$).
  This step is well defined since $\mathcal L$ is a bounded lattice
  and $\lub\emptyset$ and $\glb\emptyset$ are well defined.

  We also complement $\mathcal R$ with $(\leq)$ by adding an edge
  between related constants.
\item
  At this point, we can easily check for satisfiability: A constraint
  is satisfiable (in the given environment) if and only if,
  for any constants $l_1$ and $l_2$ such that
  there is a path from $l_1$ to $l_2$ in $\mathcal G$, then $l_1\lk_\Lat l_2$.
  If this is not the case, we return \textbf{fail}.
  
\item For each strongly connected component in $\mathcal G$, unify all its vertices and replace it by a representative.
  We note $\unif_k$ the substitution that replaces a kind variable by
  its representative.
  The representative of a strongly connected component $g$ can be determined as follows:
  \begin{itemize}
  \item If $g$ does not contain any constant, then the representative
    is a fresh kind variable.
  \item If $g$ contains exactly one constant, it is the representative.
  \item Otherwise, the initial constraint $C_0$ is not satisfiable.
  \end{itemize}
  Note that this step will also detect all unsatisfiable constraints.
\item Take the transitive closure of $\mathcal R$.
\item Remove all the vertices corresponding to the kind variables $\kvar_i$
  that are existentially quantified in $C^k$.
\item Take the transitive reduction of $\mathcal R$.
\item Remove the extremums of $\mathcal L$ and the edges of $(\leq)$
  from $\mathcal R$.
\item Return $C = \left\{ k \leq k' \mid k \operatorname{\mathcal R}k' \right\}$
  and $\unif =  \unif_\tau \meet \unif_k$.
\end{enumerate}

\TODO{Add an example}

\subsection{Soundness and Principality}

\TODO{Simplify/Cut}

\begin{lemma}[Normal form]
  \label{lemma:normalform}
  Given a constraint $D\in\CL$, a substitution $\phi$ and
  $(C,\unif) = \normalize{D}{\phi}$,
  then $\phi\leq\unif$,
  $C \equivC \unif D$ and
  $\unif C = C$.
\end{lemma}
\begin{proof}
  % For simplicity, we assume that any substitution has been already applied
  % to $D$ and that $\phi = id$.
  Let us partition $\phi$ into a part which affects type variables,
  $\phi_\tau$, and a part which affects kind variables, $\phi_k$.
  
  We note $(C^k,\unif_\tau)$ the result of
  the modified Herbrand unification on $(D,\phi)$ in step (1).
  Herbrand unification computes the most general
  unifier. Our modified Herbrand unification only output additional
  kind constraints for kind on the arrows and does not change
  the result of the unification. Thus, we have
  $\phi_\tau\leq\unif_\tau$,
  $C^k \equivC \unif_\tau D$ and
  $\unif_\tau C^k = C^k$.
  
  Let $C^{k+}$ be the result after step (2), we trivially have that
  $\fv{C^{k+}} = \fv{C^k}$ and that $C^{k+} \equivC C^k$.

  Let $C^{A}$ and $\unif_k$ be the results after step (4).
  By definition, we have $\unif_k C^{k+} \equivC C^{A}$ and
  $\unif_k C^{A} = C^{A}$. Since $\phi_k$ has already be applied to $C$ before
  unifying the strongly connected components,
  we have that $\phi_k\leq\unif_k$.

  Let $\unif = \unif_\tau \meet \unif_k$. Since $\unif_\tau$ and $\unif_k$
  have disjoint supports,
  we have $C^{A} = \unif_\tau C^{A} \equivC \unif C^{k+} \equivC \unif D$
  and $\unif C^{A} = C^{A}$.
  Furthermore, $\phi_\tau \meet \phi_k \leq \unif_\tau \meet \unif_k$.
  
  Steps (5) to (9) all preserve the free variables and the equivalence
  of constraints, which concludes.
\end{proof}

\begin{lemma}[Uniqueness]
  Given $(C_1,\unif_1)$ and $(C_2,\unif_2)$ such that
  $\unif_1 C_1 \equivC \unif_2 C_2$, then
  $\normalize{C_1}{\unif_1}$ and $\normalize{C_2}{\unif_2}$
  are identical up to $\alpha$-renaming.
\end{lemma}
\begin{proof}
  In \cref{lemma:normalform}, we have showed that all the steps of the
  normalization procedure preserve equivalence.
  Since $\unif_1 C_1 \equivC \unif_2 C_2$, equivalence between
  the two results of the normalization procedures is preserved for all steps.

  We note $P(C_a)$ if for all $C = (k, k)'$
  such that $\entail{C_a}{C}$ and $\nvdash_eC$,
  we have $C \in {\mathcal R}_a$. 

  Let us note $C_1'$ and $C_2'$ the constraints after step (4). $P(C_1')$ and
  $P(C_2')$ hold. Indeed, since $C_1'$ and $C_2'$ are only composed
  of existential quantifications and kind inequalities, the only rules
  that applies are transitivity and lattice inequalities.
  After step (2) and (5), the associated relations are fully saturated for these
  two rules, hence all inequalities that can be deduced from $C_a'$ are already
  present in the relation.

  The property $P$ is preserved by step (6) since we only remove
  inequalities that involve existentially quantified variables. Such
  inequalities could not be picked in $P$.
  % In (6) we only remove
  % trivial lattice inequalities.

  Let us note $C''_a$ for $a\in\{1,2\}$ the constraints after step (5).
  Since there are no more existential variables,
  we have $C''_a=(k_i,k'_i)_i=\mathcal R''_a$.
  For any $C=(k,k')$ such that $\entail{}{C}$ and $\entail{C''_a}{C}$,
  then $C \in (\leq) \subset {\mathcal R}''_a$.
  Indeed, the only trivial inequalities in our system are equalities of the form
  $(\kvar, \kvar)$, which were removed in step (4) and the lattice inequalities.

  Let us consider $C = (k,k') \in \mathcal R''_1$.
  Since $C''_1\equivC C''_2$, we have $\entail{C''_2}{C}$.
  If $\nvdash_e{C}$, by $P(C''_2)$ we have that
  $C\in R''_2$.
  If $\entail{}{C}$, then $C\in (\leq) \subset R''_2$.
  We conclude that $R''_1 \subset R''_2$.
  By symmetry, $R''_1 = R''_2$ and $C''_1 = C''_2$.

  This equality is preserved by step (7) and (8)
  since the transitive reduction of a directed acyclic graph is unique,
  which concludes.
\end{proof}


\begin{theorem}
  $\CL$ has the principal constraint property and
  $\operatorname{normalize}$ computes principal normal forms for $\CL$.
\end{theorem}

\begin{lemma}
  For all $C\in\mathcal S$, $\entail{C}{x = x}$ implies
  $\entail{}{x = x}$.
\end{lemma}
\begin{proof}
  By definition of $\operatorname{normalize}$, We have $C = \Cleq{k}{k'}_i$
  such that the underlying relation has no cycles.
  Thus, we can not deduce neither kind nor type equalities from $C$.
\end{proof}

\begin{lemma}
  $\CL$ is regular, ie, for $x, x'$ two types or kinds,
  $\entail{}{\Ceq{x}{x'}}$ implies
  $\fv{x} = \fv{x'}$
\end{lemma}
\begin{proof}
  The only equalities possibles are between variables (via symmetry) or
  between constants.
\end{proof}

\begin{theorem}
  Type inference in $HM(\CL)$ is sound, principal and complete.
\end{theorem}



\TODO{}

\begin{itemize}
\item Properly ensure that it respects HM(X) (cylindric, \dots)
\item Show principal type inference:
  \begin{itemize}
  \item Principal constraint system
  \item Regular constraint system: $\Ceq{\tau}{\tau'} \implies \fv{\tau} = \fv{\tau'}$.
  \item Solved forms are in simplified form.
    $C\in S, \entail{C}{\Ceq{\tau}{\tau'}} \implies \entail{}{\Ceq{\tau}{\tau'}}$.
  \end{itemize}
\item Show equivalence with the logic-based system.

\end{itemize}


% \begin{lemma}
%   Without loss of generality, we can consider that
%   kind inequalities in satisfiable constraints
%   are only done on kind variables. 

%   \begin{proof}
%     Consider the constraint $\Cleq{k}{k'}\Cand C$.
%     \begin{itemize}
%     \item If $k$ and $k'$ are both constants, it can be removed.
%     \item If the constraint is $\Cleq{\kvar}{\kaff}$ or $\Cleq{\kun}{\kvar}$, it can be removed.
%     \item If the constraint is $\Cleq{\kvar}{\kun}$ or $\Cleq{\kaff}{\kvar}$, we
%       can substitute $\kvar$ by its value in $C$.
%     \end{itemize}
%   \end{proof}
% \end{lemma}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
