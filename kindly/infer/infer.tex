\section{Type inference}

We now formulate type inference for the \lang language. Our inference technique is based on the HM(X) framework~\citep{DBLP:journals/tapos/OderskySW99} which
presents how to implement Hindley-Milner type inference in a language
with qualified types. We first present various preliminaries definitions,
we then show our extension of HM(X) that support a kind system and affine
types.

\subsection{Preliminaries}

\subsubsection{Constraint language}

We consider $\mathcal C$ the set of constrains.
The grammar of constrains, presented
in \cref{grammar:constraint}, follows the traditional HM(X) formulation
with conjunctions,projections and type inequalities. The only new
element specific to our approach are kind equalities.
Entailment is noted $\entail{C}{D}$, where $D$ is a consequence of the
constraints $C$.
The base entailment rules are shown in \cref{rules:entail}, we consider
the completion of that system to form a cylindric constraint system.
\TODO{Give the properties}

We say that $C$ and $D$ are equivalent, noted $C \equivC D$,
when $\entail{C}{D}$ and $\entail{D}{C}$.

\begin{figure}[h]
  \centering
  \begin{align*}
    C ::=&\ \Cleq{\tau_1}{\tau_2}\ |\ \Cleq{k_1}{k_2}\ |\ C_1 \Cand C_2\ |\ \Cproj{\alpha}{C}
  \end{align*}
  \caption{The constraint language}
  \label{grammar:constraint}
\end{figure}

\begin{figure*}[h]
  \input{infer/entails}
  \caption{Base entailment rules -- $\entail{C}{D}$ }
  \label{rules:entail}
\end{figure*}


We note $\mathcal S$ the set of solved forms
which can be used inside type and kind schemes.
We define $\mathcal S$ as $\mathcal C$ quotiented by the relation $\equivC$.
%
We consider the existence of a function $\normalize$ which takes
a constraint in $\mathcal C$ and a unifier $\psi$ and returns a constraint
in solved form $C' \in \mathcal S$,
and an updated unifier. We detail the implementation
of the normalization function in \cref{sec:normalize}

% $\mathcal S$ is composed only of kind
% inequalities \emph{over variables}. For convenience, if $C\in\mathcal S$, we
% note $C$ as a list of kind inequalities: $\Cleq{\kvar_i}{\kvar_{i'}}^n$.
% \TODO{Extend the properties of solved forms}



\subsubsection{Usage maps}

In order to determine if a variable is used in an affine manner, we must track
it's uses and the associated kinds. For instance, in the expression
$(x,x)$, $x$ is used twice. If $x$ is of type $\tau$, which is of kind $k$,
we must add the constraint $\Cleq{k}{\kun}$. In order to record uses and kinds,
our type inference relation will return a ``usage map'', noted $\Sv$,
which associates each variable to a list of kinds corresponding to each use site
of the variable.
We note $\Sone{x}{k_1,\dots,k_n}$ the singleton usage map.
Common operations on usages maps are defined in \cref{op:usgmap}. We define
regular set operations such as union
($\Sv\cup\Sv'$) and intersection ($\Sv\cap\Sv'$), along
with constraint creation $\Cleq{\Sv}{k_0}$ which indicates that all the kinds
presents in the usage map $\Sv$ are constrained by the kind $k_0$.
These operations corresponds roughly to the various parts of the join
operator on sets $\esplit{}{}$.

\begin{figure}[h]\centering
\begin{align*}
  \Sv\cap\Sv'
  &= \left\{ x \to l,l'
    \mid \Sone{x}{l}\in\Sv \text{ and } \Sone{x}{l'}\in\Sv' \right\} \\
  \Sv\cup\Sv'
  &= \Sv\cap\Sv' \sqcup
    (\Sv\Sdel{x' \mid x'\in\Sv'}) \sqcup
    (\Sv'\Sdel{x \mid x\in\Sv})
  &\text{where $\sqcup$ is the disjoint union}\\
  \Cleq{\Sv}{k_0}
  &= \bigwedge_{\Sone{x}{l_x}\in\Sv} \bigwedge_{k\in l_x} \Cleq{k}{k_0}
\end{align*}
\caption{Operation on usage maps $\Sv$}
\label{op:usgmap}
\end{figure}

\subsection{Kind inference}

We note $\inferK{(C,\unif)}{\bf{\E}}{\bf{\tau}}{k}$ when type $\tau$ has kind $k$
in environment $\E$ under constraints $C$ and unifier $\unif$. From an
algorithmic point of view, $\E$ and $\tau$ are the input parameters of
our inference procedure.
We present the kind inference algorithm as a set of syntax-directed rules in
\cref{rules:kinding}.
Since higher-kinded types are not supported, the type application
rule and the type constructor rule are merged in {\sc KApp}.
Additionally, type variables must be of a simple kind in rule {\sc KVar}.
Note that in the case of a type constructor with no argument, the {\sc KApp}
rule degenerates to a simpler form which is similar to the {\sc KVar} rule.
Kind schemes are instantiated in the {\sc KApp} and {\sc KVar} rules by creating
fresh kind variables and the associated substitution.

\begin{figure}[h]
  \centering
  \input{infer/kinds}
  \caption{Kind inference rules -- $\inferK{(C,\unif)}{\E}{\tau}{k}$}
  \label{rules:kinding}
\end{figure}


\subsection{Type inference}

We reformulate the HM(X) type inference in the context of our affine type
system. The main difference compared to HM(X) are noted in \addlin{blue}.
We note $\inferW{\addlin{\Sigma}}{(C,\unif)}{\bf{\E}}{\bf{e}}{\tau}$ when
$e$\ as type $\tau$ in $\E$ under the constraints $C$ and unifier $\unif$.
$\Sigma$ is a map which associates free variables in $e$ to
their kinds.
As before, $\E$ and $e$ are the input parameters of the inference
algorithm. The syntax-directed rules are shown in \cref{rules:typing}.

\begin{figure*}[h]
  \input{infer/typing}
  \caption{Type Inference rules -- $\inferW{\Sigma}{(C,\psi)}{\bf{\E}}{\bf{e}}{\tau}$ }
  \label{rules:typing}
\end{figure*}

\subsection{Normal forms and generalization}
\label{sec:normalize}

\newcommand\lub\bigvee
\newcommand\glb\bigwedge

We now place ourselves in a more general context where kinds are either variables
or constants belonging to a total bounded lattice $(\mathcal L, \leq)$ ie.,
a lattice which admits a total order and upper and lower bounds.
We note lattice elements $l$ and $\glb_i l_i$ (resp. $\lub_i l_i$)
the greatest lower bound (resp. least upper bound) in $\mathcal L$.

The normalization procedure is noted $\normalize{C_0}{\unif_0}$ where
$C_0\in \mathcal C$ is a set of constraints and $\unif_0$ is a substitution.
It returns a constraint $C \in \mathcal S$ in
solved form and a unifier $\unif$.
Our unification algorithm proceed as follows:
\begin{enumerate}
\item Solve all type equality constraints through Herband unification and
  gather all existential quantifications at the front of the constraint.
  We obtain a constraint $C^k = \exists \kvar_i,\ \Cleq{k_j}{k'_j}_j$ and
  a substitution $\unif_\tau$.
  
  We note $\mathcal R$ the relation $\Cleq{k_j}{k'_j}_j$,
  $\mathcal G$ the underlying directed graph and $V$ its vertices.

\item Saturate the lattice equalities in $\mathcal R$.
  
  More precisely, for each kind variable $\kvar \in V$,
  for each constant $l_i$ (resp. $l_j$) such that
  there is a path from $l_i$ to $\kvar$ (resp. from $\kvar$ to $l_j$) in $\mathcal G$,
  add an edge from $\lub l_i$ to $\kvar$
  (resp. from $\kvar$ to $\glb l_j$).
  This step is well defined since $\mathcal L$ is a bounded lattice
  and $\lub\emptyset$ and $\glb\emptyset$ are well defined.

  We also complement $\mathcal R$ with $(\leq)$ by adding an edge
  between related constants.
\item For each strongly connected component in $\mathcal G$, unify all its vertices and replace it by a representative.
  We note $\unif_k$ the substitution that replaces a kind variable by
  its representative.
  The representative of a strongly connected component $g$ can be determined as follows:
  \begin{itemize}
  \item If $g$ does not contain any constant, then the representative
    is a fresh kind variable.
  \item If $g$ contains exactly one constant, it is the representative.
  \item Otherwise, the initial constraint $C_0$ is not satisfiable.
  \end{itemize}
  Note that this step will also detect all unsatisfiable constraints.
\item Take the transitive closure of $\mathcal R$.
\item Remove all the vertices corresponding to the kind variables $\kvar_i$
  that are existentially quantified in $C^k$.
\item Take the transitive reduction of $\mathcal R$.
\item Remove the extremums of $\mathcal L$ and the edges of $(\leq)$
  from $\mathcal R$.
\item Return $C = \left\{ k \leq k' \mid k \operatorname{\mathcal R}k' \right\}$
  and $\unif =  \unif_\tau \meet \unif_k$.
\end{enumerate}

\TODO{Add an example}

\begin{lemma}
  Given a constraint $C\in\mathcal C$, a substitution $\unif$ and
  $(C',\unif') = \normalize{C}{\unif}$, we have the following properties:
  \begin{enumerate}
  \item $C'$ is of the form $\{ k_i \leq k'_i\}_i$.
  \item For any disjoint subformulas $C_1$ and $C_2$ of $C'$,
    then $C_1 \operatorname{\nvdash_e} C_2$ and $C_2 \operatorname{\nvdash_e} C_1$
  \item For each $\kvar \in \operatorname{fv}(C)$,
    there exists two constants $l_\bot,l_\top \in \mathcal L$  such that
    $\entail{C}{\Cleq{l_\bot}{\kvar}}$ and $\entail{C}{\Cleq{\kvar}{l_\top}}$.
  \end{enumerate}
\end{lemma}
% \begin{proof}
  
%   \begin{enumerate}
%   \item Directly follows from step (1) and (5).
%   \end{enumerate}
%   (1) is a direct consequence of step 
% \end{proof}


\begin{lemma}[Normal form]
  \label{lemma:normalform}
  Given a constraint $D\in\mathcal C$, a substitution $\phi$ and
  $(C,\unif) = \normalize{D}{\phi}$,
  then $\phi\leq\unif$,
  $C \equivC \unif D$ and
  $\unif C = C$.
\end{lemma}
\begin{proof}
  % For simplicity, we assume that any substitution has been already applied
  % to $D$ and that $\phi = id$.
  Let us partition $\phi$ into a part which affects type variables,
  $\phi_\tau$, and a part which affects kind variables, $\phi_k$.
  
  We note $(C^k,\unif_\tau)$ the result of
  the modified Herbrand unification on $(D,\phi)$ in step (1).
  Herbrand unification computes the most general
  unifier. Our modified Herbrand unification only output additional
  kind constraints for kind on the arrows and does not change
  the result of the unification. Thus, we have
  $\phi_\tau\leq\unif_\tau$,
  $C^k \equivC \unif_\tau D$ and
  $\unif_\tau C^k = C^k$.
  
  Let $C^{k+}$ be the result after step (2), we trivially have that
  $\fv{C^{k+}} = \fv{C^k}$ and that $C^{k+} \equivC C^k$.

  Let $C^{A}$ and $\unif_k$ be the results after step (3).
  By definition, we have $\unif_k C^{k+} \equivC C^{A}$ and
  $\unif_k C^{A} = C^{A}$. Since $\phi_k$ has already be applied to $C$ before
  unifying the strongly connected components,
  we have that $\phi_k\leq\unif_k$.

  Let $\unif = \unif_\tau \meet \unif_k$. Since $\unif_\tau$ and $\unif_k$
  ave disjoint supports,
  we have $C^{A} = \unif_\tau C^{A} \equivC \unif C^{k+} \equivC \unif C^{k} \equivC \unif D$
  and $\unif C^{A} = C^{A}$.
  Furthermore, $\phi_\tau \meet \phi_k \leq \unif_\tau \meet \unif_k$.
  
  Steps (4) to (8) all preserve the free variables and the equivalence
  of constraints, which concludes.
\end{proof}

\begin{lemma}[Uniqueness]
  Given $(C_1,\unif_1)$ and $(C_2,\unif_2)$ such that
  $\unif_1 C_1 \equivC \unif_2 C_2$, then
  $\normalize{C_1}{\unif_1}$ and $\normalize{C_2}{\unif_2}$
  are identical up to $\alpha$-renaming.
\end{lemma}
\begin{proof}
  In \cref{lemma:normalform}, we have showed that all the steps of the
  normalization procedure preserve equivalence.
  Since $\unif_1 C_1 \equivC \unif_2 C_2$, equivalence between
  the two results of the normalization procedures is preserved for all steps.

  We note $P(C_a)$ if for all $C = (k, k)'$
  such that $\entail{C_a}{C}$ and $\nvdash_eC$,
  we have $C \in {\mathcal R}_a$. 

  Let us note $C_1'$ and $C_2'$ the constraints after step (4). $P(C_1')$ and
  $P(C_2')$ hold. Indeed, since $C_1'$ and $C_2'$ are only composed
  of existential quantifications and kind inequalities, the only rules
  that applies are transitivity and lattice inequalities.
  After step (2) and (4), the associated relations are fully saturated for these
  two rules, hence all inequalities that can be deduced from $C_a'$ are already
  present in the relation.

  The property $P$ is preserved by step (5) since we only remove
  inequalities that involve existentially quantified variables. Such
  inequalities could not be picked in $P$.
  % In (6) we only remove
  % trivial lattice inequalities.

  Let us note $C''_a$ for $a\in\{1,2\}$ the constraints after step (5).
  Since there are no more existential variables,
  we have $C''_a=(k_i,k'_i)_i=\mathcal R''_a$.
  For any $C=(k,k')$ such that $\entail{}{C}$ and $\entail{C''_a}{C}$,
  then $C \in (\leq) \subset {\mathcal R}''_a$.
  Indeed, the only trivial inequalities in our system are equalities of the form
  $(\kvar, \kvar)$, which were removed in step (3) and the lattice inequalities.

  Let us consider $C = (k,k') \in \mathcal R''_1$.
  Since $C''_1\equivC C''_2$, we have $\entail{C''_2}{C}$.
  If $\nvdash_e{C}$, by $P(C''_2)$ we have that
  $C\in R''_2$.
  If $\entail{}{C}$, then $C\in (\leq) \subset R''_2$.
  We conclude that $R''_1 \subset R''_2$.
  By symmetry, $R''_1 = R''_2$ and $C''_1 = C''_2$.

  This equality is preserved by step (6) and (7)
  since the transitive reduction of a directed acyclic graph is unique,
  which concludes.
\end{proof}


\begin{theorem}
  The $\operatorname{normalize}$ procedure is complete and computes
  unique principal normal forms for our constraint system.
\end{theorem}


\subsection{Principality}

\TODO{}

\begin{itemize}
\item Properly ensure that it respects HM(X) (cylindric, \dots)
\item Show principal type inference:
  \begin{itemize}
  \item Principal constraint system
  \item Regular constraint system: $\Ceq{\tau}{\tau'} \implies \fv{\tau} = \fv{\tau'}$.
  \item Solved forms are in simplified form.
    $C\in S, \entail{C}{\Ceq{\tau}{\tau'}} \implies \entail{}{\Ceq{\tau}{\tau'}}$.
  \end{itemize}
\item Show equivalence with the logic-based system.

\end{itemize}


\begin{lemma}
  Without loss of generality, we can consider that
  kind inequalities in satisfiable constraints
  are only done on kind variables. 

  \begin{proof}
    Consider the constraint $\Cleq{k}{k'}\Cand C$.
    \begin{itemize}
    \item If $k$ and $k'$ are both constants, it can be removed.
    \item If the constraint is $\Cleq{\kvar}{\kaff}$ or $\Cleq{\kun}{\kvar}$, it can be removed.
    \item If the constraint is $\Cleq{\kvar}{\kun}$ or $\Cleq{\kaff}{\kvar}$, we
      can substitute $\kvar$ by its value in $C$.
    \end{itemize}
  \end{proof}
\end{lemma}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
