\section{Related work}
\label{sec:related-work}

% Haller, P., Odersky, M.: Capabilities for Uniqueness and Borrowing
% \cite{DBLP:conf/ecoop/HallerO10}

% Sing\#

% John Tang Boyland and William Retert. Connecting effects and
% uniqueness with adoption. In POPL, pages 283â€“295. ACM, 2005.
% \cite{DBLP:conf/popl/BoylandR05}


\subsection{Substructural type-systems in functional languages}

Many systems propose combinations of
functional programming and linear types in a practical setting.
\lang is to combine key ingredients
from these proposals while still preserving
complete type inference.
Many of the following languages support linear or affine types, but rarely
both. In many cases, it is easy to adapt a system to support both, as
\lang does.
None of the following languages support borrows.

System F\degree~\citep{DBLP:conf/tldi/MazurakZZ10}
extends System F with kinds to distinguish
between linear and unrestricted types.
The authors provide
a linearity-aware semantics with a soundness proof.
Unlike \lang, System F\degree{} does not allow
quantification over kinds which limits its expressivity. For instance, it
does not admit a most general type for function composition.
Being based on System F, it does not admit
principal type inference.

Quill~\citep{DBLP:conf/icfp/Morris16} is a Haskell-like language with linear
types.
Quill does not expose a kind language, but
uses the framework of qualified types to govern linearity annotations on arrows.
Its type inference algorithm is proven sound and complete.
\lang infers type signatures for all Quill examples, but often with
simpler types because Quill does not support subkinding.
Quill comes with a linearity-aware semantics and soundness proof.
Quill does not support borrows.

% For instance, the type of the constructor
% in Quill is $\qual{t \geq f}{t \to u \to t * u}$.
% In Affe, it is simply
% $\qual{(\alpha:\kvar)\implies \alpha \to \beta \tarr{\kvar} \alpha * \beta$
% with the kind of $*$ being $\kvar\to\kvar\to\kvar$.

Alms~\citep{DBLP:conf/popl/TovP11} is an ML-like language with rich, kind-based
affine types and ML modules, similar to \lang.
Alms examples often rely on existential types to track the identity
of objects. For instance
\lstinline/Array.create : int -> 'a -> \E 'b. ('a, 'b) array/ where
\lstinline/'b/ uniquely identifies the array.
Due to the reliance on existentials, Alms does not support complete type inference.
Furthermore, Alms does not support borrows and often relies
on explicit capability passing.
In our experience, \affe's limited support for existential types through
regions is sufficient to express many of Alms' examples and leads to
a more convenient programming style for imperative code.
%
Alms kind structure features unions, intersections and dependent kinds while
\lang uses constrained types.
We believe most of Alms' kind signatures can be expressed equivalently in
our system: for instance the pair type constructor
has kind $\Pi\alpha\Pi\beta. \langle\alpha\rangle \sqcup \langle\beta\rangle$
(where $\alpha$ and $\beta$ are types and $\Pi$ is the dependent function)
in Alms compared to $\kvar\to\kvar\to\kvar$ in \lang thanks
to subkinding.
%
Finally, Alms provides excellent support for abstraction through
modules by allowing to keep some type unrestricted inside a module, but
exposing it as affine. \lang supports
such programming style thanks to subsumption.

The goal of Linear Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18}
(LH) is to retrofit linear types to Haskell.
Unlike the previously discussed approaches, LH relies on ``linear
arrows'', written $\multimap$ as in linear logic, 
which are functions that \emph{use} their argument exactly once.
This design is easy to retrofit on top of an existing compiler
such as GHC, but has proven quite controversial\footnote{
  See the in-depth discussion attached to the GHC proposal starting  \href{https://github.com/ghc-proposals/ghc-proposals/pull/111\#issuecomment-403349707}{here}.}.
Most relevant to \lang:
\begin{itemize}[leftmargin=*]
\item LH does not admit subtyping for arrows and requires
  $\eta$-expansion to pass unrestricted functions in linear
  contexts. This approach is acceptable in a non-strict language such as
  Haskell but changes the semantics in a strict setting.
\item
  While the LH paper specifies a full type system along with a
  linearity-aware soundness proof, there is neither formal description of
  the type inference algorithm nor a proof of the properties of inference.
  Subsequent work~\cite{DBLP:journals/corr/abs-1911-00268}
  formalizes the inference for rank 1 qualified-types.
  However, there is an implementation of the inference as part of GHC.
\item
  LH promotes a continuation-passing style with functions such as
  \lstinline/withFile : path -> (file ->. file) ->. unit/
  to ensure linear use of resources. This style leads to problems with
  placing the annotation on, e.g., the IO monad.
  \lang follows System F\degree, Quill, and Alms, all of which support
  resource handling in direct style, where types themselves are
  described as affine or linear. (Of course, continuation-passing
  style is also supported.)
  We expect that the direct approach eases modular reasoning about linearity.
  In particular, using abstraction through modules,
  programmers only need to consider the module
  implementation to ensure that linear
  resources are properly handled.
% \item
%   Linear Haskell introduces a notion of linear monad to express
%   imperative code conveniently. Again, this solution is suitable in Haskell,
%   but less appropriate in other contexts. Our borrow system allow
%   to provide a more free-form programming style for imperative code.
% \item
%   Due to the previous remark, ensuring that a given object is never
%   aliased is fairly difficult in Linear Haskell, as one would need to ensure
%   that no non-linear function can manipulate it. On the other
\end{itemize}

Mezzo~\citep{DBLP:phd/hal/Protzenko14} is an ML-like language
with a rich capability system which is able to encode numerous
properties akin to separation logic~\citep{DBLP:conf/lics/Reynolds02}.
Mezzo explores the  boundaries of the design space of type systems for
resources. Hence, it is more expressive than \lang, but
much harder to use. The Mezzo typechecker relies on explicit
annotations and it is not known whether type inference for Mezzo is possible.

\citet{DBLP:journals/corr/abs-1803-02796} presents
an extension of OCaml for resource management in the style of C++'s RAII
and Rust's lifetimes. This system assumes
the existence of a linear type system and develops the associated compilation
and runtime infrastructure. We believe our approach is
complementary and aim to combine them in the future.

\subsection{Other substructural type-systems}

% Linear and affine disciplines have  been used in non-functional
% settings, notably in the context of low-level imperative programming
% and object systems. In particular,
\lang uses borrows and regions
which were initially developed in the context of linear and affine
typing for  imperative and
object-oriented
programming~\citep{DBLP:conf/popl/BoylandR05,DBLP:conf/pldi/GrossmanMJHWC02}.

Rust~\citep{rust} is the first
mainstream language to popularize the idea of borrowing and ownership
for safe low-level programming.
\lang is inspired by Rust's borrowing system and transfers some of its
ideas  to a functional setting with type inference, garbage collection, and
an ML-like module system.
Rust's lifetime system is more explicit and more expressive than \lang,
but Rust does not provide type inference
and only provides \emph{partial} lifetime inference.
Recently, \citet{DBLP:journals/corr/abs-1903-00982}
formalized Rust's ownership discipline, including non-lexical lifetimes.
Another important difference is that Rust allows
to precisely specify the memory layout of objects
and to pass arguments by value.
These features are crucial for the efficiency goals of Rust.
In \lang, we assume that all arguments are passed by reference and
that a garbage collector is available. This forgoes numerous
issues regarding interior mutability and algebraic data types.
In particular, it
allows us to easily nest mutable references inside objects, regardless
whether they are linear or unrestricted.

Vault~\citep{DBLP:conf/pldi/DeLineF01}
and Plaid~\citep{DBLP:conf/oopsla/AldrichSSS09}
leverage typestate and capabilities
to express rich properties in objects and protocols.
These systems are designed for either low-level or object-oriented
programming and do not immediately lend themselves to a more functional
style. While these systems are much more
powerful than \affe's, they require programmer annotations
and do not support inference.
It  would be interesting to extend \lang with limited
forms of typestate as a local, opt-in feature to provide
more expressivity at the cost of inference.

\subsection{Type-system features}
%
\lang relies on constrained types
to introduce the kind inequalities required for linear types.
\hmx~\citep{DBLP:journals/tapos/OderskySW99} 
allows us to use constrained types in an ML-like language with complete
type inference.
\hmx has been shown to be compatible with subtyping,
bounded quantification and existentials~\citep{DBLP:conf/icfp/Simonet03},
GADTs~\citep{DBLP:journals/toplas/SimonetP07},
and there exists a syntactic soundness proof~\citep{DBLP:journals/entcs/SkalkaP02}.
These results make us confident that the system developed in \lang
could be applied to larger and more complex languages such as OCaml
and the full range of features based on ad-hoc polymorphism.
% Alternatively, we could have based \lang on qualified
% types~\cite{DBLP:journals/scp/Jones94}, similarly to Quill.
% This
% choice would also be sustainable as qualified types is part of the
% foundation of Haskell's type system.

\lang's  subtyping discipline is similar
to structural subtyping, where the only subtyping (or here, subkinding)
is at the leaves.
Such a discipline is known to be friendly to inference and has been used in many
contexts, including OCaml, and has been combined
with constraints~\citep{DBLP:journals/tapos/OderskySW99,DBLP:conf/sas/TrifonovS96}.
% In particular, Flowcaml~\citep{DBLP:conf/popl/PottierS02}
% extends OCaml with security levels forming a lattice and supports type inference.
% In \lang, we repurpose these ideas to check for linearity and affinity.
It also admits classical simplification rules
\citep{DBLP:conf/aplas/Simonet03,DBLP:conf/popl/PottierS02} which we partially use
in our constraint solving algorithm.
\affe's novelty is a kind language
sufficiently simple to make
all simplification rules complete, which allows us to keep type signatures simple.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
