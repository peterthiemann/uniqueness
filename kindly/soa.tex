\section{Related work}

\subsection{Substructural type systems}

Haller, P., Odersky, M.: Capabilities for Uniqueness and Borrowing
\cite{DBLP:conf/ecoop/HallerO10}

Sing\#

John Tang Boyland and William Retert. Connecting effects and
uniqueness with adoption. In POPL, pages 283–295. ACM, 2005.
\cite{DBLP:conf/popl/BoylandR05}

Manuel Fahndrich and Robert DeLine. Adoption and focus: Practical
linear types for imperative programming. In PLDI, pages 13–24, 2002.

\subsubsection{Functional linear of affine type systems}

Many systems have attempted to combine
functional programming and linear types in a practical setting.
One contribution of \lang is to combine several ingredients
from these different languages while still preserving
complete type inference.
Many of the following languages supports linear or affine types, but rarely
both. In many cases, it is easy to adapt a system to support both, as
\lang does.
None of the following languages support borrows.

System F\degree~\citep{DBLP:conf/tldi/MazurakZZ10}
extends System F with kinds to distinguish
between linear and unrestricted types.
\citet{DBLP:conf/tldi/MazurakZZ10} also provide
(and proves soundness) of a linearity-aware semantics.
Unlike \lang, System F\degree{} does not allow
quantification over kinds which limits its expressivity. For instance, it
does not admit a most general type for function composition.
Furthermore, since it is based on System F, it does not admit
principal type inference.

Quill~\citep{DBLP:conf/icfp/Morris16} is an Haskell-like language with affine
types through the use of qualified types.
Quill does not exposes a kind language, but
uses typeclass-like mechanism and annotation on arrows.
It supports both a most general type for function composition and
principal type inference.
We believe every Quill's kind signature can be expressed in \lang by leveraging
kind inequalities.
Unlike Quill,
we provide a linearity-aware semantics and prove its soundness.
Quill does not support borrows.

% For instance, the type of the constructor
% in Quill is $\qual{t \geq f}{t \to u \to t * u}$.
% In Affe, it is simply
% $\qual{(\alpha:\kvar)\implies \alpha \to \beta \tarr{\kvar} \alpha * \beta$
% with the kind of $*$ being $\kvar\to\kvar\to\kvar$.

Alms~\citep{DBLP:conf/popl/TovP11} is an ML-like language with rich, kind-based
affine types and ML modules.
Their system often relies on existential types to track the identity
of objects. For instance, they present an array creation
functions of type \lstinline/int -> 'a -> \E 'b. ('a, 'b) array/ where
\lstinline/'a/ is the elements' type and \lstinline/'b/
is a unique identifier of the array.
Due to the reliance on existentials, Alms does not support complete type inference.
Furthermore, Alms does not support borrow and often rely
on manual passing of capabilities.
In our experience, \affe's limited support for existential types through
regions is sufficient for a large majority of examples and provides
a more convenient programming style for imperative code.
%
Apart from existential types, Alms relies
on union and intersection operators and dependent kinds while
\lang uses qualified types.
We believe most of Alms' kind signatures can be expressed equivalently in
our system: for instance the pair type constructor
has kind $\Pi\alpha\Pi\beta. \langle\alpha\rangle \sqcup \langle\beta\rangle$
(where $\alpha$ and $\beta$ are types and $\Pi$ is the dependent function)
in Alms and $\kvar\to\kvar\to\kvar$ in \lang thanks
to subkinding.
%
Finally, Alms provides excellent support for abstraction through
modules by allowing to keep some type unrestricted inside a module, but
exposing it as affine. We support a similar programming style, which
we showcase in \cref{motivation}.

Linear Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18} aims
to retrofit Haskell with linear types.
Linear Haskell introduces a new notion
of ``linear arrows'', noted $\multimap$ similar to linear logic,
which are functions who use their argument exactly once.
By contrast, in \lang linearity is only decided
by the kinds, and $\tarr{\klin}$ simply denotes \emph{single-use functions}.
This design, while easy to retrofit on top of an existing compiler
such as GHC, has several disadvantages,
as highlighted by the long discussion in the GHC proposal\footnote{
  See the in-depth discussion starting here: \url{https://github.com/ghc-proposals/ghc-proposals/pull/111\#issuecomment-403349707}}.
Most relevant to \lang:
\begin{itemize}
\item Their system does not admit subtyping for arrows and leverages
  $\eta$-expansion to allow passing unrestricted functions in linear
  contexts. This is acceptable in a non-strict language such as
  Haskell but can not be used in a strict setting.
\item
  While the GHC proposal implements \emph{some} type inference,
  their algorithm is not formalized and not proved complete.
\item
  Linear Haskell promotes a ``bracket pattern'', similar to CPS-style such as 
  \lstinline/withFile : path -> (file ->. file) -> unit/.
  \lang follows System F\degree, Quill and Alms and
  adopts a more direct style, where types themselves are
  described as affine/linear.
  We believe this leads to a more natural programming style
  and makes reasoning about linearity in the context of abstraction much easier.
% \item
%   Due to the previous remark, ensuring that a given object is never
%   aliased is fairly difficult in Linear Haskell, as one would need to ensure
%   that no non-linear function can manipulate it. On the other
\end{itemize}

\paragraph{Vault\citep{DBLP:conf/pldi/DeLineF01,DBLP:conf/pldi/FahndrichD02}}

\subsubsection{Borrows}

Rust, Non Lexical lifetimes

\subsubsection{Object systems}
\TODO{}

Plaid \&Co by Aldrich and others

\subsubsection{Uniqueness}

\subsubsection{Others}

\paragraph{Mezzo}

\subsection{Qualified Types}

HM(X)~\citep{DBLP:journals/tapos/OderskySW99} with extensions to
bounded universal and existentials~\citep{DBLP:conf/icfp/Simonet03}
and GADTs~\citep{DBLP:journals/toplas/SimonetP07},
and syntactic proof of soundness~\citep{DBLP:journals/entcs/SkalkaP02}.

\subsection{Subtyping}



Flowcaml~\citep{DBLP:conf/popl/PottierS02},
\citet{DBLP:conf/sas/TrifonovS96}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
