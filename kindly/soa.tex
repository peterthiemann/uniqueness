\section{Related work}
\label{sec:related-work}
Haller, P., Odersky, M.: Capabilities for Uniqueness and Borrowing
\cite{DBLP:conf/ecoop/HallerO10}

Sing\#

John Tang Boyland and William Retert. Connecting effects and
uniqueness with adoption. In POPL, pages 283â€“295. ACM, 2005.
\cite{DBLP:conf/popl/BoylandR05}


\subsection{Substructural type-systems in functional languages}

Many systems have attempted to combine
functional programming and linear types in a practical setting.
One contribution of \lang is to combine several ingredients
from these different languages while still preserving
complete type inference.
Many of the following languages supports linear or affine types, but rarely
both. In many cases, it is easy to adapt a system to support both, as
\lang does.
None of the following languages support borrows.

System F\degree~\citep{DBLP:conf/tldi/MazurakZZ10}
extends System F with kinds to distinguish
between linear and unrestricted types.
\citet{DBLP:conf/tldi/MazurakZZ10} also provide
(and proves soundness) of a linearity-aware semantics.
Unlike \lang, System F\degree{} does not allow
quantification over kinds which limits its expressivity. For instance, it
does not admit a most general type for function composition.
Furthermore, since it is based on System F, it does not admit
principal type inference.

Quill~\citep{DBLP:conf/icfp/Morris16} is an Haskell-like language with affine
types through the use of qualified types.
Quill does not exposes a kind language, but
uses typeclass-like mechanism and annotation on arrows.
It supports both a most general type for function composition and
principal type inference.
We were able to express the type signatures of all Quill examples
in \lang by leveraging kind inequalities.
Unlike Quill,
we provide a linearity-aware semantics and prove its soundness.
Quill does not support borrows.

% For instance, the type of the constructor
% in Quill is $\qual{t \geq f}{t \to u \to t * u}$.
% In Affe, it is simply
% $\qual{(\alpha:\kvar)\implies \alpha \to \beta \tarr{\kvar} \alpha * \beta$
% with the kind of $*$ being $\kvar\to\kvar\to\kvar$.

Alms~\citep{DBLP:conf/popl/TovP11} is an ML-like language with rich, kind-based
affine types and ML modules, similar to \lang.
Their system often relies on existential types to track the identity
of objects. For instance
\lstinline/Array.create : int -> 'a -> \E 'b. ('a, 'b) array/ where
\lstinline/'b/ uniquely identify of the array.
Due to the reliance on existentials, Alms does not support complete type inference.
Furthermore, Alms does not support borrow and often rely
on manual passing of capabilities.
In our experience, \affe's limited support for existential types through
regions is sufficient to express Alms' examples and leads to
a more convenient programming style for imperative code.
%
Kind-wise, Alms relies
on unions, intersections and dependent kinds while
\lang uses qualified types.
We believe most of Alms' kind signatures can be expressed equivalently in
our system: for instance the pair type constructor
has kind $\Pi\alpha\Pi\beta. \langle\alpha\rangle \sqcup \langle\beta\rangle$
(where $\alpha$ and $\beta$ are types and $\Pi$ is the dependent function)
in Alms and $\kvar\to\kvar\to\kvar$ in \lang thanks
to subkinding.
%
Finally, Alms provides excellent support for abstraction through
modules by allowing to keep some type unrestricted inside a module, but
exposing it as affine. We support a similar programming style, which
we showcase in \cref{motivation}.

Linear Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18} aims
to retrofit Haskell with linear types.
Linear Haskell introduces a new notion
of ``linear arrows'', noted $\multimap$ similar to linear logic,
which are functions who use their argument exactly once.
% By contrast, in \lang linearity is only decided
% by the kinds, and $\tarr{\klin}$ simply denotes \emph{single-use functions}.
This design is easy to retrofit on top of an existing compiler
such as GHC, but has several disadvantages\footnote{
  See the in-depth discussion attached to the GHC proposal starting here: \url{https://github.com/ghc-proposals/ghc-proposals/pull/111\#issuecomment-403349707}}.
Most relevant to \lang:
\begin{itemize}[leftmargin=*]
\item Their system does not admit subtyping for arrows and leverages
  $\eta$-expansion to pass unrestricted functions in linear
  contexts. This works in a non-strict language such as
  Haskell but can not be used in a strict setting.
\item
  While the GHC proposal implements some type inference,
  it is neither formalized nor complete.
\item
  Linear Haskell promotes a continuation-passing style with functions such as 
  \lstinline/withFile : path -> (file ->. file) ->. unit/
  to ensure that files are only used linearly.
  \lang follows System F\degree, Quill and Alms and
  adopts a direct style, where types themselves are
  described as affine or linear.
  We believe this leads to a more natural programming style
  and ease modular reasoning about linearity.
  In particular, using abstraction through modules,
  programmers only need to consider the module
  implementation to ensure that linear
  resources are properly handled.
% \item
%   Linear Haskell introduces a notion of linear monad to express
%   imperative code conveniently. Again, this solution is suitable in Haskell,
%   but less appropriate in other contexts. Our borrow system allow
%   to provide a more free-form programming style for imperative code.
% \item
%   Due to the previous remark, ensuring that a given object is never
%   aliased is fairly difficult in Linear Haskell, as one would need to ensure
%   that no non-linear function can manipulate it. On the other
\end{itemize}

Mezzo~\citep{DBLP:phd/hal/Protzenko14} is an ML-like language
with an extremely rich capability system which allows it to encode numerous
properties akin to separation logic~\citep{DBLP:conf/lics/Reynolds02}.
The main contribution of Mezzo is to push the boundary of what is possible
to do with a type system. This makes it far more expressive than \lang, but
also quite harder to use, and precludes any form of complete type
inference.

\subsection{Other substructural type-systems}

Linear and affine discipline have also been used in non-functional
settings, notably in the context of low-level imperative programming
and object systems. In particular, \lang uses borrows and regions
which were initially developed in objects or
imperatives settings~\citep{DBLP:conf/popl/BoylandR05,DBLP:conf/pldi/GrossmanMJHWC02}.

Rust~\citep{rust} is the first
mainstream language to popularize the idea of borrowing and ownership
for safe low-level programming.
\lang heavily draws inspiration from Rust's borrowing system to apply
it in a functional setting with type inference, a GC, and
an ML module system.
Rust's lifetime system is more explicit and more expressive than \lang,
however Rust does not provide type inference
and only provides \emph{partial} lifetime inference.
Recently, \citet{DBLP:journals/corr/abs-1903-00982}
formalized Rust's ownership discipline, including non-lexical lifetimes.
We believe this work
could help us improve our handling of regions and of successive exclusive borrows.

Vault~\citep{DBLP:conf/pldi/DeLineF01}
and Plaid~\citep{DBLP:conf/oopsla/AldrichSSS09}
leverage typestate and capabilities
to express very rich properties in objects and protocols.
These systems are designed for either low-level or object-oriented
programming, and do not immediately lend themselves to a more functional
style. Furthermore, while their type-systems are much more
powerful than \affe's, they require many annotations by the programmer
and do not support any inference.
It could however be interesting to expand \affe with limited
forms of typestate as a local, opt-in feature that would provide
more expressivity at the cost of inference.

\subsection{Type-system features}

\lang relies on qualified types~\cite{DBLP:journals/scp/Jones94}
to introduce the necessary kind equalities for linear types. In
particular, we use HM(X)~\citep{DBLP:journals/tapos/OderskySW99} which
allow to use qualified type in an ML-like language with complete
type inference.
HM(X) has been shown to be compatible with subtyping,
bounded universal and existentials~\citep{DBLP:conf/icfp/Simonet03}
GADTs~\citep{DBLP:journals/toplas/SimonetP07},
and syntactic proof of soundness~\citep{DBLP:journals/entcs/SkalkaP02}.
This makes us confident that the system developed in \lang
could be applied to larger and more complex languages such as OCaml.

The subtyping discipline used in \lang is very similar
to structural subtyping, where the only subtyping (or here, subkinding)
is at the leafs.
Such discipline is known to be friendly to inference and has be used in many
contexts, including OCaml itself, and has been combined
with constraints~\citep{DBLP:journals/tapos/OderskySW99,DBLP:conf/sas/TrifonovS96}.
In particular, Flowcaml~\citep{DBLP:conf/popl/PottierS02}
extends OCaml with security levels forming a lattice and supports type inference.
In \lang, we repurpose these ideas to check for linearity and affinity.
\citet{DBLP:conf/aplas/Simonet03} also presents various algorithmic
notions to solve lattice-based constraints, which we partially use
in our constraint solving algorithm. Our main contribution
is the design of a kind language specialized for checking linearity
and sufficient simple to make
all simplification rules complete, which allows to keep type signatures simple.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
