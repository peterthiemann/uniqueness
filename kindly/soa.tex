\section{Related work}

\subsection{Substructural type systems}

Haller, P., Odersky, M.: Capabilities for Uniqueness and Borrowing
\cite{DBLP:conf/ecoop/HallerO10}

Sing\#

John Tang Boyland and William Retert. Connecting effects and
uniqueness with adoption. In POPL, pages 283â€“295. ACM, 2005.
\cite{DBLP:conf/popl/BoylandR05}


\subsubsection{Functional languages}

Many systems have attempted to combine
functional programming and linear types in a practical setting.
One contribution of \lang is to combine several ingredients
from these different languages while still preserving
complete type inference.
Many of the following languages supports linear or affine types, but rarely
both. In many cases, it is easy to adapt a system to support both, as
\lang does.
None of the following languages support borrows.

System F\degree~\citep{DBLP:conf/tldi/MazurakZZ10}
extends System F with kinds to distinguish
between linear and unrestricted types.
\citet{DBLP:conf/tldi/MazurakZZ10} also provide
(and proves soundness) of a linearity-aware semantics.
Unlike \lang, System F\degree{} does not allow
quantification over kinds which limits its expressivity. For instance, it
does not admit a most general type for function composition.
Furthermore, since it is based on System F, it does not admit
principal type inference.

Quill~\citep{DBLP:conf/icfp/Morris16} is an Haskell-like language with affine
types through the use of qualified types.
Quill does not exposes a kind language, but
uses typeclass-like mechanism and annotation on arrows.
It supports both a most general type for function composition and
principal type inference.
We believe every Quill's kind signature can be expressed in \lang by leveraging
kind inequalities.
Unlike Quill,
we provide a linearity-aware semantics and prove its soundness.
Quill does not support borrows.

% For instance, the type of the constructor
% in Quill is $\qual{t \geq f}{t \to u \to t * u}$.
% In Affe, it is simply
% $\qual{(\alpha:\kvar)\implies \alpha \to \beta \tarr{\kvar} \alpha * \beta$
% with the kind of $*$ being $\kvar\to\kvar\to\kvar$.

Alms~\citep{DBLP:conf/popl/TovP11} is an ML-like language with rich, kind-based
affine types and ML modules.
Their system often relies on existential types to track the identity
of objects. For instance, they present an array creation
functions of type \lstinline/int -> 'a -> \E 'b. ('a, 'b) array/ where
\lstinline/'a/ is the elements' type and \lstinline/'b/
is a unique identifier of the array.
Due to the reliance on existentials, Alms does not support complete type inference.
Furthermore, Alms does not support borrow and often rely
on manual passing of capabilities.
In our experience, \affe's limited support for existential types through
regions is sufficient for a large majority of examples and provides
a more convenient programming style for imperative code.
%
Apart from existential types, Alms relies
on union and intersection operators and dependent kinds while
\lang uses qualified types.
We believe most of Alms' kind signatures can be expressed equivalently in
our system: for instance the pair type constructor
has kind $\Pi\alpha\Pi\beta. \langle\alpha\rangle \sqcup \langle\beta\rangle$
(where $\alpha$ and $\beta$ are types and $\Pi$ is the dependent function)
in Alms and $\kvar\to\kvar\to\kvar$ in \lang thanks
to subkinding.
%
Finally, Alms provides excellent support for abstraction through
modules by allowing to keep some type unrestricted inside a module, but
exposing it as affine. We support a similar programming style, which
we showcase in \cref{motivation}.

Linear Haskell~\citep{DBLP:journals/pacmpl/BernardyBNJS18} aims
to retrofit Haskell with linear types.
Linear Haskell introduces a new notion
of ``linear arrows'', noted $\multimap$ similar to linear logic,
which are functions who use their argument exactly once.
% By contrast, in \lang linearity is only decided
% by the kinds, and $\tarr{\klin}$ simply denotes \emph{single-use functions}.
This design is easy to retrofit on top of an existing compiler
such as GHC, but has several disadvantages\footnote{
  See the in-depth discussion attached to the GHC proposal starting here: \url{https://github.com/ghc-proposals/ghc-proposals/pull/111\#issuecomment-403349707}}.
Most relevant to \lang:
\begin{itemize}
\item Their system does not admit subtyping for arrows and leverages
  $\eta$-expansion to allow passing unrestricted functions in linear
  contexts. This is acceptable in a non-strict language such as
  Haskell but can not be used in a strict setting.
\item
  While the GHC proposal implements some type inference,
  their algorithm is not formalized and is not complete.
\item
  Linear Haskell promotes a CPS style with functions such as 
  \lstinline/withFile : path -> (file ->. file) ->. unit/
  to ensure that files are only used linearly.
  \lang follows System F\degree, Quill and Alms and
  adopts a direct style, where types themselves are
  described as affine or linear.
  We believe this leads to a more natural programming style
  and ease modular reasoning about linearity.
  In particular, using abstraction through modules,
  programmers only need consider the module
  implementation to ensure that some linear
  resource is properly handled.
% \item
%   Linear Haskell introduces a notion of linear monad to express
%   imperative code conveniently. Again, this solution is suitable in Haskell,
%   but less appropriate in other contexts. Our borrow system allow
%   to provide a more free-form programming style for imperative code.
% \item
%   Due to the previous remark, ensuring that a given object is never
%   aliased is fairly difficult in Linear Haskell, as one would need to ensure
%   that no non-linear function can manipulate it. On the other
\end{itemize}

Mezzo~\citep{DBLP:phd/hal/Protzenko14} is an ML-like language
with an extremely rich capability system which allows it to encode numerous
properties akin to separation logic~\citep{DBLP:conf/lics/Reynolds02}.
The main contribution of Mezzo is to push the boundary of what is possible
to do with a type system. This makes it far more expressive than \lang, but
also quite harder to use, and precludes any form of complete type
inference.

\subsubsection{Other systems}

Vault~\citep{DBLP:conf/pldi/DeLineF01}
is a low-level language which uses typestate along with \emph{keys}
to track ownership. It also introduces a novel paradigm
called \emph{adoption and focus} \citep{DBLP:conf/pldi/FahndrichD02}
which allow restricting the scope of linear objects
(adoption) or temporarily treating them as non-linear (focus).
These mechanisms serve a similar purpose as borrows, but are tracked
much more precisely thanks to the use of typestate and pre/post-conditions,
which makes it very expressive (at the cost of some verbosity).
However, Vault is mostly geared towards traditional imperative programming:
functions can't capture linear objects and it does not support
type inference.

Rust~\citep{rust} is the first
mainstream language to popularize the idea of borrowing and ownership
for safe low-level programming.
\lang heavily draws inspiration from Rust's borrowing system to apply
it in a functional setting with type inference, a GC, and
an ML module system.
Rust's lifetime system is more explicit and more expressive than \lang,
however Rust does not provide type inference
and only provides \emph{partial} lifetime inference.
Recently, \citet{DBLP:journals/corr/abs-1903-00982} presented Oxide,
a core language for Rust which formalizes its ownership discipline
including non-lexical lifetimes, which we look forward to use to improve
our borrowing system.

Plaid \&Co by Aldrich and others

\subsection{Type-system features}

\lang strongly relies on qualified types~\cite{DBLP:journals/scp/Jones94}
to introduce the necessary kind equalities in our system. In
particular, we use HM(X)~\citep{DBLP:journals/tapos/OderskySW99} which
allow to use qualified type in an ML-like language with complete
type inference.
HM(X) has been shown to be compatible with subtyping,
bounded universal and existentials~\citep{DBLP:conf/icfp/Simonet03}
GADTs~\citep{DBLP:journals/toplas/SimonetP07},
and syntactic proof of soundness~\citep{DBLP:journals/entcs/SkalkaP02}.
This makes us confident that the system developed in \lang
could be applied to larger and more complex languages such as OCaml.

The subtyping discipline we develop in \lang is very similar
to structural subtyping, where the only subtyping (or here, subkinding)
is at the leafs.
Such discipline is known to be friendly to inference and has be used in many
contexts, including OCaml itself, and has been combined
with constraints~\citet{DBLP:journals/tapos/OderskySW99,DBLP:conf/sas/TrifonovS96}.
In particular, Flowcaml~\citep{DBLP:conf/popl/PottierS02}
extends OCaml with security levels forming a lattice and supports type inference.
In \lang, we repurpose these ideas to check for linearity and affinity.
\citet{DBLP:conf/aplas/Simonet03} also presents various algorithmic
notions to solve lattice-based constraints, which we partially use
in our constraint solving algorithm. Our main contribution
is the design of a kind language specialized for checking linearity
and sufficient simple to make
all simplification rules complete, which allows to keep our type signature simple.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
