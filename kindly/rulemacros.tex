\newcommand\ruleTimeOut{%
  \inferrule[TimeOut]{}{\Store, \Perm, \VEnv \vdash e \Downarrow^0 \TimeOut}
}

\newcommand\ruleSConst[1][i]{%
  \inferrule[SConst]{}{ \Store, \Perm, \VEnv \vdash c \Downarrow^{#1+1} \Ok{\Store, \Perm, c}}
}

\newcommand\ruleSVar[1][i]{%
  \inferrule[SVar]{}{\Store, \Perm, \VEnv \vdash x \Downarrow^{#1+1} \Ok{\Store, \Perm, \VEnv(x)}}
}

\newcommand\ruleSTApp[1][i]{%
  \inferrule[STApp]{
    \Matches \Loc { \VEnv (x)} \\
    \Loc \in \Perm \\
    \Matches {(\VEnv, \ilam {\Multi[i]{\kvar}}{\Multi[j]{\tvar}}Ckx{e})}{ \Store (\Loc)}\\
    \Perm' =  \IF{\entail C {k \le \kun_\infty}}{ \Perm}{\Perm\Sdel\Loc} \\
    \Loc'\notin\Dom{\Store}  \\
    \Store' = \Store[\Loc' \mapsto (\VEnv, \subst{\Multi[j]{\tvar}}{\Multi[j]{t}}{\subst {\Multi[i]{\kvar}}{\Multi[i]{k}}{(\lam[k]xe)}}) ]
  }{\Store, \Perm, \VEnv \vdash  \ivar x{\Multi[i]{k}}{\Multi[j]{\tau}}
    \Downarrow^{#1+1} \Ok{\Store', \Perm'\Sadd{\Loc'}, \Loc'}
  }
}

\newcommand\ruleSPLam[1][i]{%
  \inferrule[SPLam]{
    \Loc'\notin\Dom\Store \\
    \Store' = \Store[\Loc' \mapsto (\VEnv, \ilam
    {\Multi[i]{\kvar}}{\Multi[j]{\tvar}}Ck xe)] \\
    \Perm' = \Perm\Sadd{\Loc'}
  }{
    \Store, \Perm, \VEnv \vdash
    \ilam {\Multi[i]{\kvar}}{\Multi[j]{\tvar}}Ck xe
    \Downarrow^{#1+1} \Ok{ \Store', \Perm', \Loc'}
  }
}

\newcommand\ruleSApp[1][i]{%
  \inferrule[SApp]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{\Store_1, \Perm_1, r_1} \\
    \Matches\Loc{ r_1} \\
    \Matches{ (\VEnv'',\lam[k]{x}{e})}{ \Store_1 (\Loc)}  \\\\
    \Perm_1' = \IF{\entail {} {k \le \kun}}{\Perm_1}{ \Perm_1\Sdel\Loc}\\
    \Store_1, \Perm_1', \VEnv \vdash e_2
    \Downarrow^{#1} \Ok{ \Store_2, \Perm_2, r_2} \\
    \Store_2, \Perm_2, \VEnv''[x\mapsto r_2] \vdash e \Downarrow^{#1}
    \Ok{\Store_3, \Perm_3, r_3}
  }{\Store, \Perm, \VEnv \vdash \app{e_1}{e_2}
    \Downarrow^{#1+1} \Ok{\Store_3,\Perm_3, r_3}
  }
}

\newcommand\ruleSLet[1][i]{%
  \inferrule[SLet]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Store_1, \Perm_1, \VEnv[x \mapsto r_1] \vdash e_2
    \Downarrow^{#1} \Ok{ \Store_2, \Perm_2, r_2}
  }{
    \Store, \Perm, \VEnv \vdash \letin{x}{e_1}{e_2}
    \Downarrow^{#1+1} \Ok{\Store_2, \Perm_2, r_2} 
  }
}

\newcommand\ruleSPair[1][i]{%
  \inferrule[SPair]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Store_1, \Perm_1, \VEnv \vdash e_2
    \Downarrow^{#1} \Ok{\Store_2, \Perm_2, r_2} \\\\
    \Loc'\notin\Dom{\Store_2} \\
    \Store_2' = \Store_2[\Loc' \mapsto \introPair[k]{r_1}{ r_2}] \\
    \Perm_2' = \Perm_2 \Sadd{\Loc'}
  }{
    \Store, \Perm, \VEnv \vdash \introPair[k]{e_1}{e_2}
    \Downarrow^{#1+1}
    \Ok{\Store_2', \Perm_2', \Loc'}
  }
}

\newcommand\ruleSMatchLocation[1][i]{%
  \inferrule[SMatchLocation]{
    \Store, \Perm, \VEnv \vdash e
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Matches{\Loc}{r_1}  \\
    \Matches{\introPair[k]{ \Addr_1}{\Addr_2}}{\Store' (\Loc)} \\
    \Perm_1' = \IF{\entail {} {k \le \kun}}{\Perm_1}{\Perm_1\Sdel\Loc} \\
    \Store_1, \Perm_1', \VEnv[x,y \mapsto \Addr_1, \Addr_2] \vdash e_2
    \Downarrow^{#1} \Ok{\Store_2, \Perm_2, r_2}
  }{
    \Store, \Perm, \VEnv \vdash \matchin[\text{id}]{x,y}{e_1}{e_2} \Downarrow^{#1+1}
    \Ok{\Store_2, \Perm_2,  r_2}
  }
}

\newcommand\ruleSMatchBorrow[1][i]{%
  \inferrule[SMatchBorrow]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Matches{\BORROW\Multi\BORROW\Loc}{r_1} \\
    \Matches{\introPair[k]{ \Addr_1}{\Addr_2}} {    \Store' (\Loc)} \\
    \Addr_1' = \Addr_1\BORROW \\
    \Addr_2' = \Addr_2\BORROW \\\\
    \Perm_1' = (\Perm'\Sdel{\Addr_1,\Addr_1}) \Sadd{\Addr'_2, \Addr'_2} \\
    \Store1, \Perm_1', \VEnv[x,y \mapsto \Addr'_1, \Addr'_2] \vdash e_2
    \Downarrow^{#1} \Ok{ \Store_2, \Perm_2, r_2} \\
    \Perm_2' = (\Perm_2 \Sdel{\Addr'_1, \Addr'_2}) \Sadd{\Addr_1,\Addr_2}
  }{
    \Store, \Perm, \VEnv \vdash \matchin[\&^\BORROW]{x,y}{e_1}{e_2} \Downarrow^{#1+1}
    \Ok{\Store_2, \Perm_2',  r_2}
  }
}

\newcommand\ruleSRegion[1][i]{%
  \inferrule[SRegion]{
    \Matches\Addr{\VEnv (x)} \\
    \Addr \in \Perm \\
    \Store, (\Perm \Sdel\Addr) \Sadd{\sborrow{\Addr}}, \VEnv \vdash e
    \Downarrow^{#1} \Ok{\Store', \Perm', r}
  }{
    \Store, \Perm, \VEnv \vdash \region{\Sone x \BORROW}{e}
    \Downarrow^{#1+1} \Ok{ \Store', (\Perm' \Sdel{\sborrow\Addr})\Sadd\Addr, r}
  }
}

\newcommand\ruleSBorrow[1][i]{%
  \inferrule[SBorrow]{
    \Matches\Addr{\VEnv (x)} \\ \sborrow\Addr \in \Perm
  }{
    \Store, \Perm, \VEnv \vdash \borrow{x}
    \Downarrow^{#1+1} \Ok{ \Store, \Perm, \sborrow\Addr}
  }
}

\newcommand\ruleSCreate[1][i]{%
  \inferrule[SCreate]{
    \Store, \Perm, \VEnv \vdash e
    \Downarrow^{#1} \Ok{ \Store', \Perm', r}\\
    \Loc\notin \Dom{\Store'} }{
    \Store, \Perm,\VEnv \vdash \create e
    \Downarrow^{#1+1} \Ok{\Store'[\Loc \mapsto \rss{r}], \Perm'\Sadd\Loc, \Loc}
  }
}

\newcommand\ruleSDestroy[1][i]{%
  \inferrule[SDestroy]{
    \Store, \Perm, \VEnv \vdash e
    \Downarrow^{#1} \Ok{ \Store', \Perm', \Loc} \\
    \Matches{\rss{r}}{\Store' (\Loc)}
  }{
    \Store, \Perm, \VEnv \vdash \destroy e \Downarrow^{#1+1}
    \Ok{\Store'[\Loc\mapsto \blob], \Perm'\Sdel\Loc, ()}
  }
}

\newcommand\ruleSObserve[1][i]{%
  \inferrule[SObserve]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Matches\Addr{r_1} \\
    \Matches{\IBORROW\Multi\IBORROW\Multi\MBORROW\Loc}\Addr \\
    \Addr \in \Perm_1 \\
    \Matches{\rss{r}}{\Store_1 (\Loc)}
  }{
    \Store, \Perm, \VEnv \vdash \observe e
    \Downarrow^{#1+1} \Ok{ \Store_1, \Perm_1, r}
  }
}

\newcommand\ruleSUpdate[1][i]{%
  \inferrule[SUpdate]{
    \Store, \Perm, \VEnv \vdash e_1
    \Downarrow^{#1} \Ok{ \Store_1, \Perm_1, r_1} \\
    \Matches\Addr{r_1} \\
    \Matches{ \MBORROW\Multi\MBORROW\Loc}\Addr \\
    \Store_1, \Perm_1, \VEnv \vdash e_2
    \Downarrow^{#1} \Ok{ \Store_2, \Perm_2, r_2} \\
    \Addr \in \Perm_2 \\
    \Matches{\rss{r}}{\Store_2 (\Loc)} \\
    \Store_2' = \Store_2[\Loc \mapsto \rss{r_2}]
  }{
    \Store, \Perm, \VEnv \vdash \update {e_1} {e_2}
    \Downarrow^{#1+1} \Ok{\Store_2', \Perm_2 \Sdel{\Addr},  ()}
  }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% syntax-directed typing
\newcommand\ruleSDVar{%
  \inferrule[Var]
  { \bvar{x}{
      \forall \kvar_i \forall (\tvar_j:k_j).\ \qual{C_x}{\tau}
    }
    \in \E \\\\
    \unif = [\kvar_i\mapsto k_i,\tvar_j \mapsto \tau_j] \\
    \entail C {\unif(C_x) \Cand \addlin{\Cleq{\E\Sdel{x}}{\kaff_\infty}}} \\
    % \addlin{
    %   \inferSK{C}{\E}{\unif \tau}{k_\tau}
    % }
  }
  { \inferS{C}{\E}{x}{\unif\tau}
  }
}

\newcommand\ruleSDLam{%
  \inferrule[Abs]
  { 
    \inferS{C}
    {\E;\bvar{x}{\tau_2}}{e}{\tau_1} \\
    \addlin{\entail{C}{\Cleq{\E}{k}}}
  }
  { \inferS{C}{\E}
    {\lam[k]{x}{e}}{\tau_2\tarr{k}\tau_1} }
}

\newcommand\ruleSDPair{
  \inferrule[Pair]
  { \addlin{\lsplit{C}{\E}{\E_1}{\E_2}} \\
    \inferS{C}{\E_1}{e_1}{\tau_1} \\
    \inferS{C}{\E_2}{e_2}{\tau_2}
  }
  { \inferS{C}{\E}{\introPair{e_1}{e_2}}{\tyPair{\tau_1}{\tau_2}} }
}

\newcommand\ruleSDApp{%
  \inferrule[App]
  { 
    \inferS{C}{\E_1}{e_1}{\tau_2 \tarr{k} \tau_1} \\
    \inferS{C}{\E_2}{e_2}{\tau'_2} \\
    \addlin{\lsplit{C}{\E}{\E_1}{\E_2}}\\
    \entail C {\Cleq{\tau_2'}{\tau_2}} 
  }
  { \inferS{C}
    {\E}{\app{e_1}{e_2}}{\tau_1} }
}

\newcommand\ruleSDRegion{%
  \inferrule[Region]
  { \svar x {\tau_x}^n \in \E \\
    \addlin{ \lregion{C_r}{x}{\E}{\E'} }\\\\
    \inferS{C}{\E'}{e}{\tau} \\
    \entail C {\Cleq{\tau}{\klin_{n-1}}} \\
  }  { \inferS{C}{\E}{\region{\Sone x \BORROW}{e}}{\tau} }
}

\newcommand\ruleSDBorrow{
  \inferrule[Borrow]
  { \bvar{\borrow x}{\borrowty k\tau} \in \E }
  { \inferS{C}{\E}{\borrow{x}}{\borrowty{k}{\tau}} }
}
\newcommand\ruleSDReBorrow{
  \inferrule[Borrow]
  { \inferS{C}{\E}{x}{\borrowty{k}{\tau}} }
  { \inferS{C}{\E}{\reborrow{x}}{\borrowty{k}{\tau}} }
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inference


\newcommand\ruleIVar{%
  \inferrule[Var$_I$]
  { \bvar{x}{\sigma}\in \E \\
    \sigma = \forall \kvar_i \forall (\tvar_j:k_j). \qual{C_x}{\tau} \\
    \Multi[i]{\kvar'},\Multi[j]{\tvar'} \text{ new} \\\\
    % \addlin{
    % \inferK{(C_\tau,\unif_\tau)}{\E;\bvar{\tvar_j}{k_j}}{\tau}{k_\tau}
    % }\\
    % D = C_x\Cand C_\tau \\
    \unif = [\kvar_i\mapsto \kvar'_i,\tvar_j \mapsto \tvar'_j]\\
    (C,\unif') =
    \normalize{C_x}{\unif}
  }
  { \inferW
    {\addlin{\bvar{x}{\sigma}}}
    {(C,\unif'|_{\fv{\E}})}{\E}{x}{\unif'\tau} }
}
\newcommand\ruleIAbs{%
  \inferrule[Abs$_I$]
  { \tvar,
    %\kvar_\tvar,
    \kvar\text{ new}\\
    \inferW{\Sv_x}{(C',\unif')}
    {\E;\bvar{x}{\tvar}
      % ;\bvar{\tvar}{\kvar_\tvar}
    }{e}{\tau} \\
    \addlin{ \Sv = \Sv_x \Sdel{x} }\\\\
    D = C'\Cand
    \addlin{\Cleq{\Sv}{\kvar} \Cand \Weaken_{\bvar{x}{\tvar}}(\Sv_x)} \\
    (C,\unif) = \normalize{D}{\unif'}
  }
  { \inferW{\addlin{\Sv}}{(C,\unif\Sdel{\tvar})}{\E}
    {\lam{x}{e}}{\unif(\tvar)\tarr{\unif(\kvar)}\tau} }
}
\newcommand\ruleIApp{%
  \inferrule[App$_I$]
  { \tvar,\kvar\text{ new}\\
    \inferW{\Sv_1}{(C_1,\unif_1)}{\E}{e_1}{\tau_1} \\
    \inferW{\Sv_2}{(C_2,\unif_2)}{\E}{e_2}{\tau_2} \\
    \addlin{\bsplit{C_s}{\Sv}{\Sv_1}{\Sv_2}}\\
    D =
    C_1 \Cand C_2 \Cand \Cleq{\tau_1}{\tau_2\tarr{\kvar}\tvar}
    \Cand \addlin{C_s} \\
    \unif' = \unif_1 \mostgeneral \unif_2 \\
    (C,\unif) = \normalize{D}{\unif'}\\
  }
  { \inferW{\addlin{\Sv}}{(C,\unif)}
    {\E}{\app{e_1}{e_2}}{\unif(\tvar)} }
}
\newcommand\ruleILet{%
  \inferrule[Let$_I$]
  { \inferW{\Sv_1}{(C_1,\unif_1)}{\E}{e_1}{\tau_1} \\
    (C_\schm,\sigma) = \generalize{C_1}{\unif_1\E}{\tau_1} \\
    \inferW{\Sv_2}{(C_2,\unif_2)}{\E;\bvar{x}{\sigma}}{e_2}{\tau_2} \\
    \unif' = \unif_1 \mostgeneral \unif_2 \\
    \addlin{\bsplit{C_s}{\Sv}{\Sv_1}{(\Sv_2 \Sdel{x})}}\\
    D =
    C_\schm \Cand C_2 \Cand
    \addlin{C_s \Cand \Weaken_{\bvar{x}{\sigma}}(\Sv_2)}  \\
    (C,\unif) = \normalize{D}{\unif'}\\
  }
  { \inferW{\addlin{\Sv}}{(C,\unif|_{\fv{\E}})}
    {\E}{\letin{x}{e_1}{e_2}}{\unif\tau_2} }
}
\newcommand\ruleIPair{%
  \inferrule[Pair$_I$]
  { \inferW{\Sv_1}{(C_1,\unif_1)}{\E}{e_1}{\tau_1} \\
    \inferW{\Sv_2}{(C_2,\unif_2)}{\E}{e_2}{\tau_2} \\
    \addlin{\bsplit{C_s}{\Sv}{\Sv_1}{\Sv_2}}\\
    D =
    C_1 \Cand C_2 \Cand \addlin{C_s} \\
    \unif' = \unif_1 \mostgeneral \unif_2 \\
    (C,\unif) = \normalize{D}{\unif'}\\
  }
  { \inferW{\Sv}{(C,\unif)}{\E}{\introPair{e_1}{e_2}}{\tyPair{\tau_1}{\tau_2}} }
}
\newcommand\ruleIMatch{%
  \inferrule[MatchPair$_I$]
  { \tvar,\kvar,\tvar',\kvar'\text{ new}\\
    \inferW{\Sv_1}{(C_1,\unif_1)}{\E}{e_1}{\tau_1} \\
    \E' = \E;
    \bvar{x}{\transfm{\tvar}};\bvar{\tvar}{\kvar};
    \bvar{x'}{\transfm{\tvar'}};\bvar{\tvar'}{\kvar'}\\
    \inferW{\Sv_2}{(C_2,\unif_2)}
    {\E'}{e_2}{\tau_2} \\
    \unif' = \unif_1 \mostgeneral \unif_2 \\
    \addlin{\bsplit{C_s}{\Sv}{\Sv_1}{(\Sv_2 \Sdel{x,x'})}}\\
    D =
    C'_1 \Cand C_2 \Cand \Cleq{\tau_1}{\transfm{\tyPair{\tvar}{\tvar'}}}
    \Cand
    \addlin{C_s
      \Cand \Weaken_{\bvar{x}{\transfm\tvar},\bvar{x'}{\transfm\tvar'}}(\Sv_2)} \\
    (C,\unif) = \normalize{D}{\unif'}\\
  }
  { \inferW{\addlin{\Sv}}{(C,\unif|_{\fv{\E}})}
    {\E}{\matchin{x,x'}{e_1}{e_2}}{\unif\tau_2} }
}
\newcommand\ruleIBorrow{%
  \inferrule[Borrow$_I$]
  { \kvar \text{ new}\\
    \inferW{\Sv}{(C,\unif)}{\E}{x}{\tau} \\
    % k = \operatorname{kind}(\iota)\\
  }
  { \inferW
    {\addlin{\bvar{\borrow{x}}{\borrowty{\kvar}{\tau}}}}
    {(C,\unif)}{\E}{\borrow{x}}{\borrowty{\kvar}{\tau}} }
}
\newcommand\ruleIReBorrow{%
  \inferrule[ReBorrow$_I$]
  { \inferW{\Sv}{(C',\unif')}{\E}{x}{\tau'} \\\\
    % k = \operatorname{kind}(\iota)\\
    (C,\unif) = \normalize{C' \Cand \Cleq{\tau'}{\borrowty{\kvar}{\tau}}}{\unif'}\\   
  }
  { \inferW
    {\addlin{\bvar{\borrow{x}}{\borrowty{\kvar}{\tau}}}}
    {(C,\unif)}{\E}{\borrow{x}}{\borrowty{\kvar}{\tau}} }
}
\newcommand\ruleIRegion{%
  \inferrule[Region$_I$]
  { \inferW{\addlin{\Sv'}}{(C',\unif')}{\E}{e}{\tau} \\
    \inferK{(C_\tau,\unif_\tau)}{\E}{\tau}{k_\tau}\\
    \addlin{ \bregion{C_r}{x}{\Sv}{\Sv'} }\\
    D = C' \Cand C_\tau \Cand \Cleq{k_\tau}{\klin_{n-1}} \Cand C_r\\
    (C,\unif) = \normalize{D}{\unif' \mostgeneral \unif_\tau}\\    
  }  { \inferW{\addlin{\Sv}}{(C,\unif)}{\E}{\region{\Sone x \BORROW}{e}}{\tau} }
}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:

