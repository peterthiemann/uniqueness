\section{Introduction}

A large proportion of systems programming is focused on the proper
handling of resources, like file handles, network connections, or
dynamically allocated memory. Each of these resources comes with a
protocol that prescribes the correct use of its API.
For examples, a file handle appears as the result of of opening a
file. If it was opened for reading, then read operations will suceed,
but write operations will fail. Once the handle is closed, it cannot
be used for reading or writing, anymore.

Dynamic allocation of memory is analogous. An API call returns a
pointer to a memory area, which can then be read and written to until
the memory is released by another API call.

In both cases, a resource is created in a certain state and a resource
handle is returned to the program. Depending on this state, certain API calls
can safely be applied to it. Finally, there is another API call to
release the resource, which yields the handle invalid.
Taken to the extreme, each API call changes the state so that a
different set of API calls is enabled afterwards. 
Ignoring such life cycle protocols is a common source of errors.
%% this is about typestate \cite{DBLP:conf/ecoop/BeckmanKA11}.


Most type systems provide just type soundness, but neglect the
protocol aspect. The systems that do build on linear types \cite{Girard} and/or
uniqueness types\cite{DBLP:conf/plilp/BarendsenS95}. A value of linear
type is guaranteed to be consumed 
exactly once. That is, a file that has been opened must be closed and
memory that has been allocated must be released. A value of unique
type is guaranteed to have a single reference to it.

These systems work well if one is prepared to write programs
functionally in resource-passing style. In this style, all operations
in the resource's API take the resource as a parameter and return it
in possibly modified state\cite{DBLP:journals/jfp/AchtenP95}. In
typestate-oriented programming, they would also modify its type
\cite{DBLP:conf/oopsla/AldrichSSS09}. Functional session types
represent a popular example \cite{DBLP:journals/jfp/GayV10}.

Explicit resource passing places a heavy burden on the programmer and
complicates the program structure. For imperative APIs,
resource-passing style is not an option at all. To this end,
\citet{DBLP:conf/popl/BoylandR05}  proposed the notion of
\emph{borrowing} a resource. The idea is that a linear resource can be
borrowed to a function call, which can work with the resource, but
cannot release it. Only the original owner of the resource has all
rights to it and can release it.

The concepts of ownership and borrowing have grown popular over time
and they form the foundation of the type system of the Rust language
\cite{rust}. Rust supports two kinds of borrows of data structures, mutable and immutable
ones. Mutable borrows enable modification of the data structure
whereas immutable borrows come only with read access. Moreover, Rust
manages the lifetime of data and makes sure that the lifetime of a
borrow is properly contained in the lifetime of its lender. 

The design of Rust is geared towards programmers with a low-level
imperative programming background, like C or C++. Its management of
lifetime supports the manual way of memory management customary in
these languages very well and makes it safe. However, programmers from
a managed language background feel alienated from the lack of garbage
collected data. They would prefer a setting where automatic memory
management with garbage collection was the default, but where they
could seemlessly switch to safe, manual resource management if that
was required.

As a concrete example, consider a functional programmer who wants to
safely interact with a C library. Invoking the C functions is easy via
the existing foreign function interface, but managing the underlying
resources like malloc'd storage is not: It cannot be left to the
garbage collector, but the proper calls to \texttt{free()} must be
ensured by programming conventions.

Our work provides a solution to programmers in this situation. We
propose an extended type system for ML-like languages that comes with
linear and affine types, mutable and immutable borrows, but all that
integrated with full type inference, garbage collected data, and
ANOTHER FEATURE.

\subsection{A first example}
\label{sec:first-example}
\begin{figure}[tp]
  \begin{subfigure}[t]{0.45\linewidth}
    \lstinputlisting{code/writefiles.affe}
    \caption{File API}
    \label{fig:writing-files-api}
  \end{subfigure}
  ~
  \begin{subfigure}[t]{0.45\linewidth}
\begin{lstlisting}
let main () =
  let h = File.fopen "foo" in
  write &!h "Hello ";
  write &!h "world!";
  File.close h
\end{lstlisting}
    \caption{File example}
    \label{fig:writing-files-example}
  \end{subfigure}
  \caption{Writing files}
  \label{fig:writing-fiules}
\end{figure}

As a first, well-trodden example we consider a very simple API for
writing files in \cref{fig:writing-files-api}.
The type \lstinline/File.t/ is linear. A call like
\lstinline/fopen "foo"/ returns a linear handle to a newly created
file, which \emph{must} be closed later using
\lstinline/close/. Failing to do so is a static type error.
To write to the file, we must take a (mutable) borrow of the handle and
pass it to the \lstinline/write/
function. As mutable borrows must not be duplicated so they are
classified as affine. This affinity shows up in the annotation of the
second arrow in the type of \lstinline/write/: a partial application
\lstinline/write &!h/ captures the affine borrow and hence the
resulting function must also be handled in an affine way.
\Cref{fig:writing-files-example} contains an example where
\lstinline/&!h/ stands for the mutable borrow.

This example demostrates two features of our system.
\begin{enumerate}
\item full type inference without annotations in user code
\item types carry multiplicity annotations in the form of kinds
\end{enumerate}

More features: kinds can be polymorphic and constrained. 

\subsection{Contributions}
\label{sec:contributions}

\begin{itemize}
\item Type system that encodes linearity and affinity with borrowing
\item Full type inference for \dots
\item Automatic inference of regions for borrows
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
