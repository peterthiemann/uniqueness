\section{The \lang language}

\subsection{Syntax}

The syntax of \lang is presented in \cref{grammar} and follows
traditional ML languages with let bindings.
Data constructors are introduced by $\introK{K}{e}$ and eliminated
with by $\elimK{K}{e}$.
Types are composed of type variable $\tvar$, parameterized type constructors
$\T{t}$ and arrow types annotated with a kind, noted $\tau \tarr{k} \tau$.
Kinds can be either a kind variable $\kvar$, affine $\kaff$ or unrestricted $\kun$.
Type schemes and kind schemes are guarded by a set of constraints.

Environments are composed of value and type bindings, along with type
declarations. Type declarations, of the form
$\tydecl{t}{\kschm}{K}{\tau}$, introduce both a new type constructor $\T{t}$ and
a data constructor $K$.

\begin{figure*}[t]
  \centering
  \input{grammar}
  \caption{Syntax}
  \label{grammar}
\end{figure*}
\input{internal-grammar}

\clearpage
\subsection{Semantics}
\input{fig-reduction}
\input{fig-code}

\clearpage
\subsection{Typing}

\subsubsection{Constraint language}

\newcommand\A{\mathcal A}
\newcommand\SC{\mathcal S}

Let us note $\A$ our constraint system. The grammar of constraints is
given in  \cref{grammar:constraint}.
$\A$ is defined as the smallest cylindric term constraint system that
satisfies the axiom shown in \cref{rules:entail}.
We follows the traditional HM(X) formulation
with conjunctions, projections and type inequalities.
The new element specific to our approach are kind inequalities.
Entailment is noted $\entail{C}{D}$, where $D$ is a consequence of the
constraints $C$.
We say that $C$ and $D$ are equivalent, noted $C \equivC D$,
when $\entail{C}{D}$ and $\entail{D}{C}$.
\TODO{Give the cylindric properties ?}

\begin{figure}[tp]
  \centering
  \begin{align*}
    C &::= \Cleq{\tau_1}{\tau_2}
        \mid \Cleq{k_1}{k_2}
        \mid C_1 \Cand C_2
        \mid \Cproj{\tvar}{C}
        \mid \Cproj{\kvar}{C}
  \end{align*}
  \caption{The constraint language}
  \label{grammar:constraint}
\end{figure}

\begin{figure*}[tp]
  \input{infer/lattice}
  \caption{Lattice inequalities -- $k \lk_\Lat k'$}
  \input{infer/entails}
  \caption{Base entailment rules -- $\entail{C}{D}$ }
  \label{rules:entail}
\end{figure*}


We note $\SC$ the set of solved forms
which can be used inside type and kind schemes.
We define $\SC$ as $\A$ quotiented by the relation $\equivC$.
%
We consider the existence of a function $\operatorname{normalize}$ which takes
a constraint in $\A$ and a substitution $\psi$ and returns a constraint
in solved form $C' \in \SC$,
and an updated substitution. We detail the implementation
of the normalization function in \cref{sec:normalize}

% $\mathcal S$ is composed only of kind
% inequalities \emph{over variables}. For convenience, if $C\in\mathcal S$, we
% note $C$ as a list of kind inequalities: $\Cleq{\kvar_i}{\kvar_{i'}}^n$.
% \TODO{Extend the properties of solved forms}

\subsubsection{Kinding}


\begin{figure}[ht]
  \centering
  \input{infer/sd-kinds}
  \caption{Syntax-directed kind inference --
    $\inferSK{C}{\E}{\tau}{(\Multi k)k}$}
  \label{rules:sd-kinding}
\end{figure}

\subsubsection{Environments}


\begin{figure}[tp]
  \input{infer/sd-splitting}
  \caption{Splitting --- environments $\lsplit
    C\E\E\E$; binders $\bsplit Cbbb$}
  \label{fig:sd-splitting}
\end{figure}

\begin{figure}[tp]
  \input{infer/sd-borrowing}
  \caption{Borrowing --- environments $\lsplit
    C\E\E\E$; binders $\bsplit Cbbb$}
  \label{fig:sd-borrowing}
\end{figure}

\subsubsection{Typing}

\begin{figure*}[tp]
  \input{infer/sd-environments}
  \caption{Rewriting constraints on environments and types}
  \label{fig:contraints-environments-types}
\end{figure*}
\begin{figure*}[tp]
  \input{infer/sd-typing}
  \caption{Syntax-directed typing rules}
  \label{fig:syntax-directed-typing}
\end{figure*}

\clearpage

\subsection{Annotating regions}

\begin{figure*}[htp]
  \centering
  \input{region-annot}
  \caption{Automatic region annotation --- $\Rannot{e}{e'}{B}$}
  \label{fig:region-annotation}
\end{figure*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
