\section{The \lang language}

We now present a formalization of the \lang language featuring
a minimal ML language with let-polymorphism, abstract types, pairs, and our novel
linear type system with borrows which uses kinds and qualified types.
For ease of presentation,
our formalization makes the following simplifications.
First, we only consider matching on pairs, instead of arbitrary algebraic
datatypes. We consider separate operators for borrowing and reborrowing (taking
the borrow of a borrow). We consider regions to be fully annotated
and present a set of rules to infer their placement.
Finally we emulates region variables
as a series of nesting indices.

In the rest of this section, we present the syntax (\cref{syntax}),
a linearity-aware semantics (\cref{sem}), syntax directed typing rules
(\cref{sdtyping}) and automatic rules for region annotations (\cref{regionannot}).

\subsection{Syntax}
\label{syntax}

Let us first define our conventions and meta-syntactic variables.
Expressions, types and kinds are noted respectively $e$, $\tau$, and $k$.
Variables, type variables and kind variables are noted
respectively $x$, $\tvar$ and $\kvar$. Types and kind schemes
are noted $\schm$ and $\kschm$.
In the rest of the text, we will write lists with a bar and an index, for
instance $\Multi[i]{\tau}$.
Kind constants are noted in bold capital letters, such as $\kaff$ for affine.

The syntax of \lang is presented in \cref{grammar} and follows
traditional ML languages with let bindings.
Borrows, noted $\borrow{e}$, are annotated with a specification indicating
if a borrow is immutable ($\IBORROW$) or mutable ($\MBORROW$).
We also distinguish reborrows, which are noted $\reborrow{e}$.
Match are indexed with a specification which can be either $\&^b$
(which $b$ a borrow specification) or $id$, indicating if the match
should operate on borrows or not.
Regions, noted $\region{x}{e}$ are annotated with their nesting ($n$)
and the variable whose borrow they enclose ($x$).
%
$\tapp{t}{\Multi{\tau}}$ denotes a type application where
$\T t$ is an abstract type constructor.
Arrow and borrow types are annotated with a kind, noted $\tau \tarr{k} \tau$
and $\borrowty{k}{\tau}$ respectively.
%
Kinds can be either a kind variable $\kvar$, or constants
(linear $\klin$, affine $\kaff$ or unrestricted $\kun$) indexed
by a nesting level represented by a member of $N \cup \{\infty\}$.
Type schemes and kind schemes are guarded by a set of constraints.
%
Finally, constraints are composed of a list of kind inequalities.


\TODO{Do we explain environments here, or push that for typing, later on ?}

% Environments are composed of value and type bindings, along with type
% declarations. Type declarations, of the form
% $\tydecl{t}{\kschm}{K}{\tau}$, introduce both a new type constructor $\T{t}$ and
% a data constructor $K$.

\begin{figure*}[t]
  \centering
  \input{grammar}
  \caption{Syntax}
  \label{grammar}
\end{figure*}

\subsection{Typing}
\label{sdtyping}

We now present the essential parts of our \lang's type system. A complete
description of the system is available in \cref{appendix:sdtyping}.
In this section, we focus on chosen parts of our system
through a set of selected rules.
%
We first define the following typing, kinding and constraint judgements:
\begin{description}
\item[$\inferS{C}{\E}{e}{\tau}$ --]
  Expression $e$ has type $\tau$ in environment $\E$ under constraints $C$.
\item[$\inferSK{C}{\E}{\tau}{k}$ --]
  Type $\tau$ has kind $k$ in environment $\E$ under constraints $C$.
\item[$\entail{D}{C}$ --] Constraint $D$ implies constraint $C$.
\end{description}

We will now present the novel aspects of our system which are necessary to handle
three specific features: binders, borrows, and sharing.


\subsubsection{Environments and bindings}

One main feature of our system is to control the usage of variables, either
through
linearity and affinity, which controls how variables are shared or ignored,
or through borrows, which allow to circumvent the linearity rules
in a controlled way.
In order to check these properties, we introduce several new bindings
in our typing environments.
The grammar of type environment (noted $\E$) is shown in \cref{grammar:env}.
On top of the traditional type and value bindings, noted respectively
$\bvar{\tvar}{\kschm}$ and $\bvar{x}{\schm}$, we also consider two new
bindings.
Borrow bindings $\bvar{\borrow{x}}{\borrowty{k}{\tau}}$ which indicates
that the borrow $\borrow{x}$ can be used directly, as implemented
by the rule {\sc Borrow} in \cref{selectrules:borrow}.
Suspended bindings, noted $\svar{x}{\schm}^n$, indicates that $x$
cannot be used immediately, but will be usable in a region
marked with $x$ (as detailed in \cref{sdtyp:regions}).

In \lang, many properties are encoded through the use of environment-wide
constraints. Here we present how to control both unused variables and
closure captures through such environment constraints, noted $\Cleq{\E}{k}$.
The intuitive meaning of $\Cleq{\E}{k}$ is that for all bindings
$\bvar{x}{\tau}$ in $\E$,
if type $\tau$ has kind $k'$ ($\inferSK{C}{\E}{\tau}{k'}$)
then $\Cleq{k'}{k}$.
While this definition is incomplete, it is sufficient to understand
its use in the {\sc Abs} and {\sc Var} rules shown in \cref{selectrules:binders}.
%
The {\sc Var} rule looks up the type scheme of the variable $x$ in
the environment $\E$
and instantiate a concrete type through the substitution $\unif$. It then
checks that the other bindings in $\E$ can safely be discarded by
ensuring they are not linear. This is achieved through the constraint
$\Cleq{\E\Sdel{X}}{\kaff_\infty}$.
%
The {\sc Lam} constraints must ensures that if the body of the lambda captures
linear or affine variable, the content will be reflected in the kind
annotated on the arrow, such as $\tau_2 \tarr{k} \tau_1$.
In order to do so, we constraint all the bindings of $\E$ to be less than $k$.
If one of the binding of $\E$ constraints a type whose kind is affine,
we will derive the constraints $\Cleq{\kaff_n}{k}$, which ensures that
the kind on the arrow is at least affine.

\begin{figure}[!h]
  \begin{minipage}{0.33\linewidth}
    \begin{align*}
      \E &::=\ \Eempty \mid \E;B\tag{Environments}\\
      B &::=\ \bnone \tag{Empty} \\
         &\mid \bvar{x}{\schm}\tag{Variables}\\
         &\mid \bvar{\borrow{x}}{\borrowty{k}{\tau}}\tag{Borrows}\\
         &\mid \svar{x}{\schm}^n \tag{Suspended}\\
         &\mid \bvar{\tvar}{\kschm}\tag{Types}
         % |&\ \tydecl{t}{\kschm}{K}{\tau}\tag{Type Declaration}\\
    \end{align*}
    \caption{Type environments}
    \label{grammar:env}
  \end{minipage}\hfill
  \begin{minipage}{0.65\linewidth}
    \begin{mathpar}
      \ruleSDBorrow
      \and
      \ruleSDLam
      \and
      \ruleSDVar
    \end{mathpar}
    \caption{The {\sc Borrow} rule}
    \label{selectrules:borrow}
  \end{minipage}
\end{figure}



\subsubsection{Copying and Splitting}

Linear and affine types also control the copy of variables.
We now showcase how this is achieved in \lang through the {\sc Pair} typing rule
in \cref{sdtyp:pair}.
\TODO{Explain splitting}

\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.35\linewidth}
    \begin{mathpar}
      \ruleSDPair
    \end{mathpar}
    \caption{The {\sc Pair} rule}
    \label{sdtyp:pair}
  \end{subfigure}\hfill
  \begin{subfigure}{0.6\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $=$ }
      >{$}c<{$}@{ $\ltimes$ }
      >{$}c<{$}r}
      
      \Cleq{\schm}{\kun_\infty}
      &\bvar{x}{\schm}&\bvar{x}{\schm}&\bvar{x}{\schm}
      &Both\\[2mm]

      {\Cempty}&{\bvar{x}{\schm}}&{\bvar{x}{\schm}}&{\bnone}
      &Left\\
      {\Cempty}&{\bvar{x}{\schm}}&{\bnone}&{\bvar{x}{\schm}}
      &Right\\[2mm]

      {\Cempty}&{\bvar x \schm}&{\svar x \schm^n}&{\bvar x \schm}
      &Susp\\

      {\Cempty}&
      {\bvar{\borrow x} \schm}&{\svar[\IBORROW] x \schm^n}&{\bvar{\borrow x} \schm}
      &SuspB\\[2mm]

      {\Cempty}&
      {\bvar{\borrow[i]{x}}{\schm}}&
      {\bvar{\borrow[i]{x}}{\schm}}&{\bvar{\borrow[i]{x}}{\schm}}
      &Borrow\\

    \end{tabular}
    \caption{Splitting rules for bindings}
  \end{subfigure}
\end{figure}


\subsubsection{Regions}
\label{sdtyp:regions}

In order to provide good support for imperative programming, \affe allows
to borrow resources.
Such borrows are constrained to a given syntactic region. We note
$\region{x}{e}$ for the region allowing borrows of $x$ to be used in $e$
and where $n$ is the nesting of the region.
Borrows can not be used outside of a corresponding region.
These remarks lead to an
algorithm for automatic region annotation: start from each borrow, create
a region, and extend it as much as possible while respecting other borrows
and binders.
A complete specification of the algorithm is provided in \cref{regionannot}.
In the rest of this section, we will only consider terms
with fully annotated regions.

\TODO{Transition}

In order to use a suspended binding for the variable $x$,
we need to enter a \emph{region} associated with $x$,
noted $\region{x}{e}$.
The main idea of region typing (implemented by the {\sc Region} rule)
is to replace suspended bindings by borrow bindings, typecheck the body
of the region, and finally ensure that the borrow made available inside
the region does not leak outside.
This last check is done by using integer indices that correspond to the nesting
level of the region. The kind of borrow is annotated with the integer
corresponding to their region, and a final constraint ensure that
the return type of the region does not contain such borrow.

We illustrate this on the expression $\region{x}{f(\borrow[\IBORROW]{c})}$.
The first step is to check that
$\svar[\IBORROW]{c}{\text{channel}}$ is in $\E$. We then define $\E'$ which
corresponds to $\E$ where the suspended binding is replaced by a borrow binding.
%
This is done by the borrow relation, noted $\lregion{C}{x}{\E}{\E'}$ and
whose main rules are shown in \cref{env:rule:region}.
In our case, we consider an immutable binding, so we replace the suspended
binding by $\bvar{\borrow[\IBORROW]{c}}{\borrowty[\IBORROW]{k}{\text{channel}}}$.
We must also check that $\entail{C}{(\kun_n\lk k\lk\kun_\infty)}$.
We can then typecheck the body of the region, $f(\borrow[\IBORROW]{c})$ for our example and check that the borrow made available in the region does not escape.
This is done by the constraint $\Cleq{\tau}{\klin_{n-1}}$, which ensures
that the kind of $\tau$ does not contain anything whose kind is ``above $n$''
(for instance, $\borrowty[\IBORROW]{\kun_n}{\text{channel}}$ would have kind
$\kun_n$).

\begin{figure}[!h]
  \begin{minipage}{0.35\linewidth}
    \centering
    \begin{mathpar}
      \ruleSDRegion
    \end{mathpar}
    \caption{The {\sc Region} rule}
    \label{selectrules:region}
  \end{minipage}\hfill
  \begin{minipage}{0.6\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $\rightsquigarrow_n^{x}$ }
      >{$}l<{$}
      r}

      {(\kun_n\lk k\lk\kun_\infty)}
      &{\svar[\IBORROW]{x}{\tau}^n}
      &{\bvar{\borrow[\IBORROW]{x}}{\borrowty[\IBORROW] k{\tau}}}
      &Immut\\

      (\kaff_n\lk k\lk\kaff_\infty)
      &\svar[\MBORROW]{x}{\tau}^n
      &\bvar{\borrow[\MBORROW]{x}}{\borrowty[\MBORROW] k{\tau}}
      &Mut
    \end{tabular}
    \caption{Borrowing rules for bindings -- $\lregion{C}{x}{\E}{\E'}$}
    \label{env:rule:borrow}
  \end{minipage}
\end{figure}






\subsubsection{Constraints}





\clearpage
\subsection{Semantics}
\label{sem}

\input{internal-grammar}
\input{fig-reduction}
\input{fig-code}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
