\section{The \lang language}

\lang is a minimal ML-like language with
let-polymorphism, abstract types, and pairs. Its type system manages
linearity and borrows using kinds and (kind-) constrained types.
For ease of presentation, we keep the language as simple as possible.
\begin{itemize}
\item Pattern matching is demonstrated on pairs rather than algebraic
  datatypes.
\item There are separate operators for borrowing and reborrowing (taking
  the borrow of a borrow).
\item Regions are assumed to be explicit in the code. (But we present
  an algorithm to infer them in \cref{regionannot}.)
\item Regions are identified using de Bruijn-indexing instead of region
  variables. 
\end{itemize}

The rest of this section formalizes  \lang: the syntax (\cref{syntax}),
the statics in terms of syntax directed typing (\cref{sdtyping}),
and a dynamics that is linearity- and resource-aware (\cref{sem}).

\subsection{Syntax}
\label{syntax}


\Cref{grammar} defines the syntax of \lang. Expressions are as usual
in an ML-like language.  The novel aspects are match
specifications, regions, and borrows.

We start from the bottom.
A borrow $\borrow{x}$ is always taken from a variable $x$. The
\emph{borrow annotation} $\BORROW$ indicates whether the borrow is mutable
($\MBORROW$) or immutable ($\IBORROW$). If $x$ is already borrowed,
then we need to use the reborrow expression $\reborrow{x}$.

A region $\region{\Sone x\BORROW}{e}$ is annotated with its nesting $n$, the variable $x$ that may be borrowed in $e$, and the kind of borrow $\BORROW$.

A match is indexed with a \emph{match specification} $\etransfm$ that indicates
whether the match should work on borrows ($\etransfm=\&^b$) or not ($\etransfm=id$).

Many types are indexed with kinds, ranged over by $k$.
A kind is either a kind variable $\kvar$ or a constant
(linear $\klin$, affine $\kaff$, or unrestricted $\kun$) indexed
by a nesting level $n \in \Nat \cup \{\infty\}$.

A type $\tau$ is either a type variable, a function type indexed by a
kind, 
a type application $\tapp{t}{\Multi{\tau}}$ of an abstract type constructor
$\T t$, or a borrowed type  $\borrowty{k}{\tau}$.

Type schemes $\schm$ add quantification over kind
variables $\kappa$, kinded type variables $\alpha:k$, and constraints
$C$ to a type, where a constraint is a list of inequalities over
kinds.

Abstract type constructors possess kind schemes $\kschm$ which relate
the kinds of the type constructors arguments to the kind of the
constructed type.

Generally, we write lists with an overbar and (sometimes) an index as
in $\Multi[i]\tau$.

% \paragraph{Previously}


% Let us first define our conventions and meta-syntactic variables.
% Expressions, types and kinds are noted respectively $e$, $\tau$, and $k$.
% Variables, type variables and kind variables are noted
% respectively $x$, $\tvar$ and $\kvar$. Types and kind schemes
% are noted $\schm$ and $\kschm$.
% In the rest of the text, we will write lists with a bar and an index, for
% instance $\Multi[i]{\tau}$.
% Kind constants are noted in bold capital letters, such as $\kaff$ for affine.

% The syntax of \lang is presented in \cref{grammar} and follows
% traditional ML languages with let bindings.
% Borrows, noted $\borrow{e}$, are annotated with a specification indicating
% if a borrow is immutable ($\IBORROW$) or mutable ($\MBORROW$).
% We also distinguish reborrows, which are noted $\reborrow{e}$.
% Match are indexed with a specification which can be either $\&^b$
% (which $b$ a borrow specification) or $id$, indicating if the match
% should operate on borrows or not.
% Regions, noted $\region{\Sone x\BORROW}{e}$ are annotated with their nesting ($n$)
% and the variable whose borrow they enclose ($x$).
% %
% $\tapp{t}{\Multi{\tau}}$ denotes a type application where
% $\T t$ is an abstract type constructor.
% Arrow and borrow types are annotated with a kind, noted $\tau \tarr{k} \tau$
% and $\borrowty{k}{\tau}$ respectively.
% %
% Kinds can be either a kind variable $\kvar$, or constants
% (linear $\klin$, affine $\kaff$ or unrestricted $\kun$) indexed
% by a nesting level represented by a member of $N \cup \{\infty\}$.
% Type schemes and kind schemes are guarded by a set of constraints.
% %
% Finally, constraints are composed of a list of kind inequalities.

% Environments are composed of value and type bindings, along with type
% declarations. Type declarations, of the form
% $\tydecl{t}{\kschm}{K}{\tau}$, introduce both a new type constructor $\T{t}$ and
% a data constructor $K$.

\begin{figure*}[t]
  \centering
  \input{grammar}
  \caption{Syntax}
  \label{grammar}
\end{figure*}

\subsection{Typing}
\label{sdtyping}

In this section, we focus on the essential and novel parts of the type system. A complete
description is available in \cref{appendix:sdtyping}.
% In this section, we focus on chosen parts of our system
% through a set of selected rules.
%
We discuss judgments for typing, kinding, and constraint entailment:
\begin{description}
\item[$\inferS{C}{\E}{e}{\tau}$ --]
  Expression $e$ has type $\tau$ in environment $\E$ under constraints $C$.
\item[$\inferSK{C}{\E}{\tau}{k}$ --]
  Type $\tau$ has kind $k$ in environment $\E$ under constraints $C$.
\item[$\entail{D}{C}$ --] Constraint $D$ entails constraint $C$.
\end{description}

\subsubsection{Kinds and constraints}

\affe uses of kinds and constrained types to indicate
linear and affine types.
% Before explaining the details of our type system, we
% give a quick presentation of the kinds and constraints.
A kind $k$ is either a kind variable, $\kvar$, or a constant.
Each constant is composed of a ``quality'' and a ``level''.
The quality describes the use pattern of the type. It can be
unrestricted $\kun$, affine $\kaff$, or linear $\klin$. The level  $n \in \Nat \cup \{\infty\}$
describes the nested regions in which the value can be used.
Level $0$ refers to the top-level scope outside any region; we often elide it
and write $\kaff$ for $\kaff_0$. Level
$\infty$ refers to an empty region that is infinitely nested.
For instance, the constraint $\Cleq{\kvar}{\kun_\infty}$ indicates that
$\kvar$ must be unrestricted, but can be local to a region.

Kinds form a lattice with an ordering that implements two principles
(see \cref{sdtyp:lattice}). First, unrestricted values may be used
where affine ones are expected and affine ones are less restricted
than linear one as reflected in \TirName{Lat-UA} and \TirName{Lat-AL}.
Second, values usable at level $n$ may be used at any more deeply
nested level $n'$ (where $n\le\infty$ for any $n$) as defined in the \TirName{Lat-X-Level} axioms. 

Constraints are conjunctions of inequality constraints over this kind
lattice. In most uses, a constraint gives an upper or lower bound for
a kind variable or it relates two kind variables.

\begin{figure*}[tp]
  \input{infer/lattice}
  \caption{Lattice ordering -- $k \lk_\Lat k'$}
  \label{sdtyp:lattice}
\end{figure*}


\subsubsection{Environments and bindings}
\label{sdtyping:envs}
\begin{figure}[tp]
  \begin{minipage}{0.33\linewidth}
    \begin{align*}
      \E &::=\ \Eempty \mid \E;B\tag{Environments}\\
      B &::=\ \bnone \tag{Empty} \\
         &\mid \bvar{x}{\schm}\tag{Variables}\\
         &\mid \bvar{\borrow{x}}{\borrowty{k}{\tau}}\tag{Borrows}\\
         &\mid \svar{x}{\schm}^n \tag{Suspended}\\
         &\mid \bvar{\tvar}{\kschm}\tag{Types}
         % |&\ \tydecl{t}{\kschm}{K}{\tau}\tag{Type Declaration}\\
    \end{align*}
    \caption{Type environments}
    \label{grammar:env}
  \end{minipage}\hfill
  \begin{minipage}{0.65\linewidth}
    \begin{mathpar}
      \ruleSDBorrow
      \and
      \ruleSDLam
      \and
      \ruleSDVar
    \end{mathpar}
    \caption{The {\sc Borrow}, {\sc Abs} and {\sc Var} rules}
    \label{selectrules:borrow}
    \label{selectrules:binders}
  \end{minipage}
\end{figure}

\lang controls the use of variables by supporting new modes of
binding in a type environment $\E$.
Its definition is given in  \cref{grammar:env}.
In addition to standard bindings of type variables to kind schemes,
$\bvar{\tvar}{\kschm}$,  and value bindings, $\bvar{x}{\schm}$, there
are suspended bindings and borrow bindings.
A suspended binding, $\svar{x}{\schm}^n$, indicates that $x$ is
earmarked for a borrowing use in a nested region
marked with $x$ (see \cref{sdtyping:regions}), but
cannot be used directly.
A borrow binding, $\bvar{\borrow{x}}{\borrowty{k}{\schm}}$, replaces
such a suspended binding on entry to the $x$-region. It indicates 
that the borrow $\borrow{x}$ can be used directly. The kind $k$
restricts the lifetime of the borrow to the region (see \cref{selectrules:borrow}).

% , either
% through
% linearity and affinity which restrict how variables are shared and ignored,
% or through borrows which allow to circumvent the linearity rules
% in a controlled way.
% In order to check these properties, we introduce several new bindings
% in our typing environments.
% The grammar of type environment (noted $\E$) is shown in \cref{grammar:env}.

% Environments are also used to encode several linearity-related properties
% through \emph{environment-wide constraints}.
Constraints on an environment control substructural properties by
restricting the types of variables.  The constraint $\Cleq{\E}{k}$
abbreviates $\Cleq\schm k$, for all $\bvar{x}{\schm}$
% $\svar{x}\schm$, and $\bvar{\borrow{x}}{\borrowty{k'}{\schm}}$
in $\E$, which in turn means that $k' \lk k$ where $k'$ is the kind of
the variable's type scheme.
Borrow bindings follow the exact same rules, but suspended bindings
are forbidden in an environment $\E$ constrained like that.
This intuitive explanation is sufficient to understand
the {\sc Abs} and {\sc Var} rules shown in
\cref{selectrules:binders}. 

The {\sc Var} rule looks up the type scheme of the variable $x$ in
the environment $\E$
and instantiates it using the substitution $\unif$. The rule also
checks that the other bindings in $\E$ can be safely discarded by
imposing the constraint $\Cleq{\E\Sdel{x}}{\kaff_\infty}$. 
It enforces that all remaining bindings (except $x$) are affine or
unrestricted and can therefore be discarded.

The {\sc Abs} rule ensures that the kind annotation on the arrow type
($\tau_2 \tarr{k} \tau_1$) reflects the restrictions on the captured variables.
To do so, the rule imposes the constraint $\Cleq\E k$.
If, for instance, any binding in $\E$ is affine, it gives rise to the
constraint $\Cleq{\kaff_n}{k}$, so that  the arrow kind is at least
affine at nesting level $n$.
Capturing a borrow is perfectly fine: the kind of the borrow is also a
lower bound of the arrow kind $k$ which restricts the closure
to the region of the borrow.
Capturing a suspended binding is forbidden.
% Note that $x$ is \emph{not} included in $\E$: since it's the argument of the
% closure, its use should not induce a capture.




\subsubsection{Copying and Splitting}
\label{sdtyping:split}

Linear and affine types also control the copy of variables.
To demonstrate how this is achieve in \lang, we show the
{\sc Pair} typing rule in \cref{sdtyp:pair}.
In the {\sc Pair} rule, we split the type environment $\E$ in two parts,
$\E_1$ and $\E_2$, which are used to typecheck the components of the pair.
We note the splitting $\lsplit{C}{\E}{\E_1}{\E_2}$ where $C$ is a constraint
that must be respected for the split to be valid.
The main splitting rules are shown in \cref{sdtyp:split}. Each
rule applies to a binding for a given variable. For instance, the
{\sc Both} rule indicates that if we can prove that $x$ is unrestricted, we
can duplicate it in both environments.
Similarly, since immutable borrows are always unrestricted, the
{\sc Borrow} rule allows to duplicate them arbitrarily.
The {\sc Left} and {\sc Right} rule allow to move a binding
to the left or right environment.
The {\sc Susp} and {\sc SuspB} allow to split off suspended bindings to
the left environment while conserving access to the binding on the right.
Such suspended binding can later be turned
into a borrow inside a region. The asymmetry here must always follow
the order of execution of the language: in \affe, execution is from left to
right, which means that a resource can be used as a borrow on the left
and then as a full resource on the right, assuming that the borrow does not
escape. The {\sc Susp} rule work with a full resource while the {\sc SuspB}
rule allow to split off an immutable suspended binding based off a borrow.

Using these various rules, we can distribute the bindings every time an
expression has multiple sub-expressions such as pairs, function applications
and let bindings. For instance, in the
expression
$\letin{a}{\text{create}\ 10\ x}
{\introPair{\region[{}]{\Sone x\IBORROW}{\app{\text{length}}{\borrow[\IBORROW]{a}}}}{a}}$,
we use the rule {\sc Susp} to detach a borrow on the left of the pair.
Naturally, we must here ensure that the borrow on the left of the pair does not
escape, which brings us to the typing rules for regions.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.35\linewidth}
    \begin{mathpar}
      \ruleSDPair
    \end{mathpar}
    \caption{The {\sc Pair} rule}
    \label{sdtyp:pair}
  \end{subfigure}\hfill
  \begin{subfigure}{0.6\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $=$ }
      >{$}c<{$}@{ $\ltimes$ }
      >{$}c<{$}r}
      
      \Cleq{\schm}{\kun_\infty}
      &\bvar{x}{\schm}&\bvar{x}{\schm}&\bvar{x}{\schm}
      &Both\\[2mm]

      {\Cempty}&{\bvar{x}{\schm}}&{\bvar{x}{\schm}}&{\bnone}
      &Left\\
      {\Cempty}&{\bvar{x}{\schm}}&{\bnone}&{\bvar{x}{\schm}}
      &Right\\[2mm]

      {\Cempty}&{\bvar x \schm}&{\svar x \schm^n}&{\bvar x \schm}
      &Susp\\

      {\Cempty}&
      {\bvar{\borrow x} \schm}&{\svar[\IBORROW] x \schm^n}&{\bvar{\borrow x} \schm}
      &SuspB\\[2mm]

      {\Cempty}&
      {\bvar{\borrow[i]{x}}{\schm}}&
      {\bvar{\borrow[i]{x}}{\schm}}&{\bvar{\borrow[i]{x}}{\schm}}
      &Borrow\\

    \end{tabular}
    \caption{Splitting rules for bindings}
    \label{sdtyp:split}
  \end{subfigure}
\end{figure}


\subsubsection{Regions}
\label{sdtyping:regions}

In order to provide good support for imperative programming, \affe allows
to borrow resources.
Such borrows are constrained to a given syntactic region. We note
$\region{\Sone x\BORROW}{e}$ the region which allow borrows of $x$ to be used in $e$
and where $n$ is the nesting of the region.
Borrows can not be used outside of a corresponding region.
These remarks lead to an
algorithm for automatic region annotation: start from each borrow, create
a region, and extend it as much as possible while respecting other borrows
and binders.
A complete specification of the algorithm is provided in \cref{regionannot}.
In the rest of this section, we will only consider terms
with fully annotated regions.

The main idea of region typing (implemented by the {\sc Region} rule)
is to replace suspended bindings by borrow bindings, typecheck the body
of the region, and finally ensure that the borrow made available inside
the region does not leak outside.
This last check is done by using integer indices that correspond to the nesting
level of the region. The kind of borrow is annotated with the integer
corresponding to their region, and a final constraint ensure that
the return type of the region does not contain such borrow.

We illustrate this on the expression $\region{\Sone x\IBORROW}{f(\borrow[\IBORROW]{c})}$
when $c$ is a linear channel.
The first step is to check that
$\svar[\IBORROW]{c}{\text{channel}}$ is in $\E$. We then define $\E'$ which
corresponds to $\E$ where the suspended binding is replaced by a borrow binding.
%
This is done by the borrow relation, noted $\lregion{C}{x}{\E}{\E'}$ and
whose main rules are shown in \cref{selectrules:region}.
In our case, we consider an immutable binding, so we replace the suspended
binding by $\bvar{\borrow[\IBORROW]{c}}{\borrowty[\IBORROW]{k}{\text{channel}}}$.
We must also check that $\entail{C}{(\kun_n\lk k\lk\kun_\infty)}$.
We can then typecheck the body of the region, $f(\borrow[\IBORROW]{c})$ in our example, and check that the borrow made available in the region does not escape.
This is done by the constraint $\Cleq{\tau}{\klin_{n-1}}$, which ensures
that the kind of $\tau$ does not contain anything whose kind is ``above $n$''
(for instance, $\borrowty[\IBORROW]{\kun_n}{\text{channel}}$ would have kind
$\kun_n$).

\begin{figure}[!h]
  \begin{minipage}{0.4\linewidth}
    \centering
    \begin{mathpar}
      \ruleSDRegion
    \end{mathpar}
    \caption{The {\sc Region} rule}
    \label{selectrules:region}
  \end{minipage}\hfill
  \begin{minipage}{0.6\linewidth}
    \centering
    % \begin{tabular}
    %   {@{}>{$}r<{$}@{ $\vdash_e$ }
    %   >{$}c<{$}@{ $\rightsquigarrow_n^{x}$ }
    %   >{$}l<{$}
    %   r}

    %   (\kun_n\lk k\lk\kun_\infty)
    %   &{\svar[\IBORROW]{x}{\tau}^n}
    %   &{\bvar{\borrow[\IBORROW]{x}}{\borrowty[\IBORROW] k{\tau}}}
    %   &Immut\\

    %   (\kaff_n\lk k\lk\kaff_\infty)
    %   &\svar[\MBORROW]{x}{\tau}^n
    %   &\bvar{\borrow[\MBORROW]{x}}{\borrowty[\MBORROW] k{\tau}}
    %   &Mut
    % \end{tabular}
    \begin{mathpar}
      \inferrule{
        \entail{C}{(\BORROW_n\lk k\lk \BORROW_\infty)}\\
        \BORROW\in\left\{\kun;\kaff\right\}
      }{
        \lregion{C}{}
        {\svar[\BORROW]{x}{\tau}^n}
        {\bvar{\borrow[\BORROW]{x}}{\borrowty[\BORROW] k{\tau}}}
      }
    \end{mathpar}
    \caption{Borrowing rules for bindings -- $\lregion{C}{x}{\E}{\E'}$}
    \label{env:rule:borrow}
  \end{minipage}
\end{figure}


\subsubsection{Kind checking}

\TODO{Present this if we have enough space}

\subsubsection{Pattern matching}

\TODO{Present this if we have enough space}

\clearpage
\subsection{Semantics}
\label{sem}

\input{internal-grammar}
\input{fig-reduction}
\input{fig-code}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
