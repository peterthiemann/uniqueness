\section{The \lang language}

We now present a formalization of the \lang language featuring
a minimal ML language with let-polymorphism, abstract types, pairs, and our novel
linear type system with borrows which uses kinds and qualified types.
For ease of presentation,
our formalization makes the following simplifications.
First, we only consider matching on pairs, instead of arbitrary algebraic
datatypes. We consider separate operators for borrowing and reborrowing (taking
the borrow of a borrow). We consider regions to be fully annotated
and present a set of rules to infer their placement.
Finally we emulates region variables
as a series of nesting indices.

In the rest of this section, we present the syntax (\cref{syntax})
the syntax directed typing rules (\cref{sdtyping})
and a linearity-aware semantics (\cref{sem}) for \lang.

\subsection{Syntax}
\label{syntax}

Let us first define our conventions and meta-syntactic variables.
Expressions, types and kinds are noted respectively $e$, $\tau$, and $k$.
Variables, type variables and kind variables are noted
respectively $x$, $\tvar$ and $\kvar$. Types and kind schemes
are noted $\schm$ and $\kschm$.
In the rest of the text, we will write lists with a bar and an index, for
instance $\Multi[i]{\tau}$.
Kind constants are noted in bold capital letters, such as $\kaff$ for affine.

The syntax of \lang is presented in \cref{grammar} and follows
traditional ML languages with let bindings.
Borrows, noted $\borrow{e}$, are annotated with a specification indicating
if a borrow is immutable ($\IBORROW$) or mutable ($\MBORROW$).
We also distinguish reborrows, which are noted $\reborrow{e}$.
Match are indexed with a specification which can be either $\&^b$
(which $b$ a borrow specification) or $id$, indicating if the match
should operate on borrows or not.
Regions, noted $\region{x}{e}$ are annotated with their nesting ($n$)
and the variable whose borrow they enclose ($x$).
%
$\tapp{t}{\Multi{\tau}}$ denotes a type application where
$\T t$ is an abstract type constructor.
Arrow and borrow types are annotated with a kind, noted $\tau \tarr{k} \tau$
and $\borrowty{k}{\tau}$ respectively.
%
Kinds can be either a kind variable $\kvar$, or constants
(linear $\klin$, affine $\kaff$ or unrestricted $\kun$) indexed
by a nesting level represented by a member of $N \cup \{\infty\}$.
Type schemes and kind schemes are guarded by a set of constraints.
%
Finally, constraints are composed of a list of kind inequalities.

% Environments are composed of value and type bindings, along with type
% declarations. Type declarations, of the form
% $\tydecl{t}{\kschm}{K}{\tau}$, introduce both a new type constructor $\T{t}$ and
% a data constructor $K$.

\begin{figure*}[t]
  \centering
  \input{grammar}
  \caption{Syntax}
  \label{grammar}
\end{figure*}

\subsection{Typing}
\label{sdtyping}

We now present the essential parts of our \lang's type system. A complete
description of the system is available in \cref{appendix:sdtyping}.
In this section, we focus on chosen parts of our system
through a set of selected rules.
%
We introduce the following typing, kinding and constraint judgements:
\begin{description}
\item[$\inferS{C}{\E}{e}{\tau}$ --]
  Expression $e$ has type $\tau$ in environment $\E$ under constraints $C$.
\item[$\inferSK{C}{\E}{\tau}{k}$ --]
  Type $\tau$ has kind $k$ in environment $\E$ under constraints $C$.
\item[$\entail{D}{C}$ --] Constraint $D$ implies constraint $C$.
\end{description}

\subsubsection{Kinds and constraints}

One novel feature or \affe is the use of kinds and qualified types to encode
linear and affine types. Before explaining the details of our type system, we
give a quick presentation of the kinds and constraints.
A kind $k$ can be either a kind variable, $\kvar$, or a constant.
Each constant is composed of a ``quality'' and a ``level''.
The quality describes the use pattern of the type and can be
either unrestricted $\kun$, affine $\kaff$ or linear $\klin$. The level
describes the nested regions in which it can be used. Levels are represented
by a natural number of $\infty$.
$0$ represents the normal scope outside of any region and is often omitted
(for instance $\kaff_0$ is simply noted $\kaff$).
$\infty$ is the empty region that is infinitely nested and is mostly used
as an upper bound.
For instance, the constraint $\Cleq{\kvar}{\kun_\infty}$ indicates that
$\kvar$ must be unrestricted, but can be local to a region.
%
Just as presented before, constraints present in schemes and type signatures
are simply a list of atomic constraints, which are composed
of kind inequalities.
%
Our inequality constraints are based on an inequality relation on
kind constants noted $\lk_\Lat$. This relation forms a lattice
and  is summarized in
\cref{sdtyp:lattice}. We have the basic inequalities on qualities:
$\kun_n \lk_\Lat \kaff_n \lk_\Lat \klin_n$ for arbitrary regions $n$.
Additionally, the inequality follows the region nesting, for
instance $\kaff_n \lk_\Lat \kaff_{n+1}$.

\begin{figure*}[!h]
  \input{infer/lattice}
  \caption{Lattice inequalities -- $k \lk_\Lat k'$}
  \label{sdtyp:lattice}
\end{figure*}


\subsubsection{Environments and bindings}
\label{sdtyping:envs}

\lang aims to control the usage of variables, either
through
linearity and affinity which restrict how variables are shared and ignored,
or through borrows which allow to circumvent the linearity rules
in a controlled way.
In order to check these properties, we introduce several new bindings
in our typing environments.
The grammar of type environment (noted $\E$) is shown in \cref{grammar:env}.
On top of the traditional type and value bindings, noted respectively
$\bvar{\tvar}{\kschm}$ and $\bvar{x}{\schm}$, we also consider two new
bindings.
Borrow bindings $\bvar{\borrow{x}}{\borrowty{k}{\tau}}$ indicates
that the borrow $\borrow{x}$ can be used directly, as implemented
by the rule {\sc Borrow} in \cref{selectrules:borrow}.
Suspended bindings, noted $\svar{x}{\schm}^n$, indicates that $x$
cannot be used immediately, but will be usable in a region
marked with $x$, which we detail in \cref{sdtyp:regions}.

Environments are also used to encode several linearity-related properties
through \emph{environment-wide constraints}.
Here we present how to control both unused variables and
closure captures through such environment constraints, noted $\Cleq{\E}{k}$.
The intuitive meaning of $\Cleq{\E}{k}$ is that for all bindings
$\bvar{x}{\tau}$ in $\E$,
if type $\tau$ has kind $k'$ (noted $\inferSK{C}{\E}{\tau}{k'}$)
then the following constraints should hold: $\Cleq{k'}{k}$.
While this definition is incomplete, it is sufficient to understand
its use in the {\sc Abs} and {\sc Var} rules shown in \cref{selectrules:binders}.
%
The {\sc Var} rule looks up the type scheme of the variable $x$ in
the environment $\E$
and instantiate a concrete type through the substitution $\unif$. It then
checks that the other bindings in $\E$ can safely be discarded by
ensuring they are not linear. This is achieved through the constraint
$\Cleq{\E\Sdel{x}}{\kaff_\infty}$ which replaces the traditional
``weakening'' rule found in many type systems.

The {\sc Abs} rule must ensures that if the body of the lambda captures
linear or affine variables, the content will be reflected in the kind
annotated on the arrow, such as $\tau_2 \tarr{k} \tau_1$.
In order to do so, we constraint all the bindings of $\E$ to be less than $k$.
If one of the binding of $\E$ contains a type whose kind is affine,
we will derive the constraints $\Cleq{\kaff}{k}$, which ensures that
the kind on the arrow is at least affine.
Note that $x$ is \emph{not} included in $\E$: since it's the argument of the
closure, its use should not induce a capture.

\begin{figure}[!h]
  \begin{minipage}{0.33\linewidth}
    \begin{align*}
      \E &::=\ \Eempty \mid \E;B\tag{Environments}\\
      B &::=\ \bnone \tag{Empty} \\
         &\mid \bvar{x}{\schm}\tag{Variables}\\
         &\mid \bvar{\borrow{x}}{\borrowty{k}{\tau}}\tag{Borrows}\\
         &\mid \svar{x}{\schm}^n \tag{Suspended}\\
         &\mid \bvar{\tvar}{\kschm}\tag{Types}
         % |&\ \tydecl{t}{\kschm}{K}{\tau}\tag{Type Declaration}\\
    \end{align*}
    \caption{Type environments}
    \label{grammar:env}
  \end{minipage}\hfill
  \begin{minipage}{0.65\linewidth}
    \begin{mathpar}
      \ruleSDBorrow
      \and
      \ruleSDLam
      \and
      \ruleSDVar
    \end{mathpar}
    \caption{The {\sc Borrow}, {\sc Abs} and {\sc Var} rules}
    \label{selectrules:borrow}
    \label{selectrules:binders}
  \end{minipage}
\end{figure}



\subsubsection{Copying and Splitting}
\label{sdtyping:split}

Linear and affine types also control the copy of variables.
To demonstrate how this is achieve in \lang, we show the
{\sc Pair} typing rule in \cref{sdtyp:pair}.
In the {\sc Pair} rule, we split the type environment $\E$ in two parts,
$\E_1$ and $\E_2$, which are used to typecheck the components of the pair.
We note the splitting $\lsplit{C}{\E}{\E_1}{\E_2}$ where $C$ is a constraint
that must be respected for the split to be valid.
The main splitting rules are shown in \cref{sdtyp:split}. Each
rule applies to a binding for a given variable. For instance, the
{\sc Both} rule indicates that if we can prove that $x$ is unrestricted, we
can duplicate it in both environments.
Similarly, since immutable borrows are always unrestricted, the
{\sc Borrow} rule allows to duplicate them arbitrarily.
The {\sc Left} and {\sc Right} rule allow to move a binding
to the left or right environment.
The {\sc Susp} and {\sc SuspB} allow to split off suspended bindings to
the left environment while conserving access to the binding on the right.
Such suspended binding can later be turned
into a borrow inside a region. The asymmetry here must always follow
the order of execution of the language: in \affe, execution is from left to
right, which means that a resource can be used as a borrow on the left
and then as a full resource on the right, assuming that the borrow does not
escape. The {\sc Susp} rule work with a full resource while the {\sc SuspB}
rule allow to split off an immutable suspended binding based off a borrow.

Using these various rules, we can distribute the bindings every time an
expression has multiple sub-expressions such as pairs, function applications
and let bindings. For instance, in the
expression
$\letin{a}{\text{create}\ 10\ x}
{\introPair{\region[{}]{x}{\app{\text{length}}{\borrow[\IBORROW]{a}}}}{a}}$,
we use the rule {\sc Susp} to detach a borrow on the left of the pair.
Naturally, we must here ensure that the borrow on the left of the pair does not
escape, which brings us to the typing rules for regions.

\begin{figure}[!h]
  \centering
  \begin{subfigure}{0.35\linewidth}
    \begin{mathpar}
      \ruleSDPair
    \end{mathpar}
    \caption{The {\sc Pair} rule}
    \label{sdtyp:pair}
  \end{subfigure}\hfill
  \begin{subfigure}{0.6\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $=$ }
      >{$}c<{$}@{ $\ltimes$ }
      >{$}c<{$}r}
      
      \Cleq{\schm}{\kun_\infty}
      &\bvar{x}{\schm}&\bvar{x}{\schm}&\bvar{x}{\schm}
      &Both\\[2mm]

      {\Cempty}&{\bvar{x}{\schm}}&{\bvar{x}{\schm}}&{\bnone}
      &Left\\
      {\Cempty}&{\bvar{x}{\schm}}&{\bnone}&{\bvar{x}{\schm}}
      &Right\\[2mm]

      {\Cempty}&{\bvar x \schm}&{\svar x \schm^n}&{\bvar x \schm}
      &Susp\\

      {\Cempty}&
      {\bvar{\borrow x} \schm}&{\svar[\IBORROW] x \schm^n}&{\bvar{\borrow x} \schm}
      &SuspB\\[2mm]

      {\Cempty}&
      {\bvar{\borrow[i]{x}}{\schm}}&
      {\bvar{\borrow[i]{x}}{\schm}}&{\bvar{\borrow[i]{x}}{\schm}}
      &Borrow\\

    \end{tabular}
    \caption{Splitting rules for bindings}
    \label{sdtyp:split}
  \end{subfigure}
\end{figure}


\subsubsection{Regions}
\label{sdtyping:regions}

In order to provide good support for imperative programming, \affe allows
to borrow resources.
Such borrows are constrained to a given syntactic region. We note
$\region{x}{e}$ the region which allow borrows of $x$ to be used in $e$
and where $n$ is the nesting of the region.
Borrows can not be used outside of a corresponding region.
These remarks lead to an
algorithm for automatic region annotation: start from each borrow, create
a region, and extend it as much as possible while respecting other borrows
and binders.
A complete specification of the algorithm is provided in \cref{regionannot}.
In the rest of this section, we will only consider terms
with fully annotated regions.

The main idea of region typing (implemented by the {\sc Region} rule)
is to replace suspended bindings by borrow bindings, typecheck the body
of the region, and finally ensure that the borrow made available inside
the region does not leak outside.
This last check is done by using integer indices that correspond to the nesting
level of the region. The kind of borrow is annotated with the integer
corresponding to their region, and a final constraint ensure that
the return type of the region does not contain such borrow.

We illustrate this on the expression $\region{x}{f(\borrow[\IBORROW]{c})}$.
The first step is to check that
$\svar[\IBORROW]{c}{\text{channel}}$ is in $\E$. We then define $\E'$ which
corresponds to $\E$ where the suspended binding is replaced by a borrow binding.
%
This is done by the borrow relation, noted $\lregion{C}{x}{\E}{\E'}$ and
whose main rules are shown in \cref{selectrules:region}.
In our case, we consider an immutable binding, so we replace the suspended
binding by $\bvar{\borrow[\IBORROW]{c}}{\borrowty[\IBORROW]{k}{\text{channel}}}$.
We must also check that $\entail{C}{(\kun_n\lk k\lk\kun_\infty)}$.
We can then typecheck the body of the region, $f(\borrow[\IBORROW]{c})$ in our example, and check that the borrow made available in the region does not escape.
This is done by the constraint $\Cleq{\tau}{\klin_{n-1}}$, which ensures
that the kind of $\tau$ does not contain anything whose kind is ``above $n$''
(for instance, $\borrowty[\IBORROW]{\kun_n}{\text{channel}}$ would have kind
$\kun_n$).

\begin{figure}[!h]
  \begin{minipage}{0.35\linewidth}
    \centering
    \begin{mathpar}
      \ruleSDRegion
    \end{mathpar}
    \caption{The {\sc Region} rule}
    \label{selectrules:region}
  \end{minipage}\hfill
  \begin{minipage}{0.6\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $\rightsquigarrow_n^{x}$ }
      >{$}l<{$}
      r}

      {(\kun_n\lk k\lk\kun_\infty)}
      &{\svar[\IBORROW]{x}{\tau}^n}
      &{\bvar{\borrow[\IBORROW]{x}}{\borrowty[\IBORROW] k{\tau}}}
      &Immut\\

      (\kaff_n\lk k\lk\kaff_\infty)
      &\svar[\MBORROW]{x}{\tau}^n
      &\bvar{\borrow[\MBORROW]{x}}{\borrowty[\MBORROW] k{\tau}}
      &Mut
    \end{tabular}
    \caption{Borrowing rules for bindings -- $\lregion{C}{x}{\E}{\E'}$}
    \label{env:rule:borrow}
  \end{minipage}
\end{figure}


\subsubsection{Kind checking}

\TODO{Present this if we have enough space}

\subsubsection{Pattern matching}

\TODO{Present this if we have enough space}

\clearpage
\subsection{Semantics}
\label{sem}

\input{internal-grammar}
\input{fig-reduction}
\input{fig-code}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
