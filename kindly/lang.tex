\section{The \lang language}

\lang is a minimal ML-like language with
let-polymorphism, abstract types, and pairs. Its type system manages
linearity and borrows using kinds and (kind-) constrained types.
For ease of presentation, we simplify the language.
\begin{itemize}
\item Pattern matching is demonstrated on pairs rather than algebraic
  datatypes.
\item There are separate operators for borrowing and reborrowing (taking
  the borrow of a borrow).
\item Regions are assumed to be explicit in the code. (But we present
  an algorithm to infer them in \cref{regionannot}.)
\item Regions are identified using nesting levels instead of region
  variables.
\end{itemize}

The rest of this section formalizes  \lang: the syntax (\cref{syntax}),
the statics in terms of syntax-directed typing (\cref{sdtyping}),
and a dynamics that is linearity- and resource-aware (\cref{sec:sem}).

\subsection{Syntax}
\label{syntax}

\begin{figure}[!tb]
  \input{grammar}
  \caption{Syntax}
  \label{grammar}
\end{figure}


\Cref{grammar} defines the syntax of \lang. Expressions are as usual
in an ML-like language.  The novel aspects are match
specifications, regions, and borrows.

We start from the bottom.
A borrow $\borrow{x}$ is always taken from a variable $x$. The
\emph{borrow annotation} $\BORROW$ indicates whether the borrow is exclusive
($\MBORROW$) or shared ($\IBORROW$). If $x$ is already borrowed,
then we need to use the reborrow expression $\reborrow{x}$.
%
A region $\region{\Sone x\BORROW}{e}$ is annotated with its nesting $n$, the variable $x$ that may be borrowed in $e$, and the kind of borrow $\BORROW$.
%
A match is indexed with a \emph{match specification} $\etransfm$ that indicates
whether the match should work on borrows ($\etransfm=\&^b$) or not ($\etransfm=id$).

Many types are indexed with kinds, ranged over by $k$.
A kind is either a kind variable $\kvar$ or a constant
(linear $\klin$, affine $\kaff$, or unrestricted $\kun$) indexed
by a nesting level $n \in \Nat \cup \{\infty\}$.

A type $\tau$ is either a type variable, a function type indexed by a
kind,
a type application $\tapp{\tcon}{\Multi{\tau}}$ of an abstract type constructor
$\T t$, or a borrowed type  $\borrowty{k}{\tau}$.

Type schemes $\schm$ add quantification over kind
variables $\kappa$, kinded type variables $\alpha:k$, and constraints
$C$ to a type, where a constraint is a list of inequalities over
kinds.

Abstract type constructors possess kind schemes $\kschm$ which relate
the kinds of the type constructors arguments to the kind of the
constructed type.

Generally, we write lists with an overbar and (sometimes) an index as
in $\Multi[i]\tau$.

% \paragraph{Previously}


% Let us first define our conventions and meta-syntactic variables.
% Expressions, types and kinds are denoted respectively as $e$, $\tau$, and $k$.
% Variables, type variables and kind variables are denoted
% respectively as $x$, $\tvar$ and $\kvar$. Types and kind schemes
% are denoted by $\schm$ and $\kschm$.
% In the rest of the text, we will write lists with a bar and an index, for
% instance $\Multi[i]{\tau}$.
% Kind constants are denoted in bold capital letters, such as $\kaff$ for affine.

% The syntax of \lang is presented in \cref{grammar} and follows
% traditional ML languages with let bindings.
% Borrows $\borrow{e}$ are annotated with a specification indicating
% if a borrow is immutable ($\IBORROW$) or mutable ($\MBORROW$).
% We also distinguish reborrows, which are written as $\reborrow{e}$.
% Match are indexed with a specification which can be either $\&^b$
% (which $b$ a borrow specification) or $id$, indicating if the match
% should operate on borrows or not.
% Regions $\region{\Sone x\BORROW}{e}$ are annotated with their nesting ($n$)
% and the variable whose borrow they enclose ($x$).
% %
% $\tapp{\tcon}{\Multi{\tau}}$ denotes a type application where
% $\T t$ is an abstract type constructor.
% Arrow and borrow types are annotated with a kind, written as $\tau \tarr{k} \tau$
% and $\borrowty{k}{\tau}$ respectively.
% %
% Kinds can be either a kind variable $\kvar$, or constants
% (linear $\klin$, affine $\kaff$ or unrestricted $\kun$) indexed
% by a nesting level represented by a member of $N \cup \{\infty\}$.
% Type schemes and kind schemes are guarded by a set of constraints.
% %
% Finally, constraints are composed of a list of kind inequalities.

% Environments are composed of value and type bindings, along with type
% declarations. Type declarations, of the form
% $\tydecl{t}{\kschm}{K}{\tau}$, introduce both a new type constructor $\T{t}$ and
% a data constructor $K$.

\subsection{Typing}
\label{sdtyping}

In this section, we focus on the essential and novel parts of the type system. A complete
description is available in \cref{appendix:sdtyping}.
% In this section, we focus on chosen parts of our system
% through a set of selected rules.
%
We discuss judgments for typing, kinding, and constraint entailment:
\begin{description}
\item[$\inferS{C}{\E}{e}{\tau}$ --]
  Expression $e$ has type $\tau$ in environment $\E$ under constraints $C$.
\item[$\inferSK{C}{\E}{\tau}{k}$ --]
  Type $\tau$ has kind $k$ in environment $\E$ under constraints $C$.
\item[$\entail{D}{C}$ --] Constraint $D$ entails constraint $C$.
\end{description}

\subsubsection{Kinds and constraints}

\affe uses kinds and constrained types to indicate
linear and affine types.
% Before explaining the details of our type system, we
% give a quick presentation of the kinds and constraints.
A kind $k$ is either a kind variable, $\kvar$, or a constant.
Each constant is composed of a ``quality'' and a ``level''.
The quality describes the use pattern of the type. It can be
unrestricted $\kun$, affine $\kaff$, or linear $\klin$. The level  $n \in \Nat \cup \{\infty\}$
describes the nested regions in which the value can be used.
Level $0$ refers to the top-level scope outside any region; we often elide it
and write $\kaff$ for $\kaff_0$. Level
$\infty$ refers to an empty region that is infinitely nested.
For instance, the constraint $\Cleq{\kvar}{\kun_\infty}$ indicates that
$\kvar$ must be unrestricted, but can be local to a region.

Kinds form a lattice with an ordering that implements two principles
(see \cref{sdtyp:lattice}). First, unrestricted values may be used
where affine ones are expected and affine ones are less restricted
than linear ones as reflected in \TirName{Lat-UAL}.
Second, values usable at level $n$ may be used at any more deeply
nested level $n'$ (where $n\le\infty$ for any $n$) as defined in the \TirName{Lat-Level} axioms.

Constraints are conjunctions of inequality constraints over this kind
lattice. In most uses, a constraint gives an upper or lower bound for
a kind variable or it relates two kind variables.

\begin{figure}[tp]
  \input{infer/lattice}
  \caption{Lattice ordering -- $k \lk_\Lat k'$}
  \label{sdtyp:lattice}
\end{figure}


\subsubsection{Environments and bindings}
\label{sdtyping:envs}
\begin{figure*}[tp]
  \begin{minipage}{0.28\linewidth}
    \begin{align*}
      \E &::=\ \Eempty \mid \E;B\tag{Environments}\\
      B &::=\ \bnone \tag{Empty} \\
         &\mid \bvar{x}{\schm}\tag{Variables}\\
         &\mid \bvar{\borrow{x}}{\borrowty{k}{\tau}}\tag{Borrows}\\
         &\mid \svar{x}{\schm}^n \tag{Suspended}\\
         &\mid \bvar{\tvar}{\kschm}\tag{Types}
         % |&\ \tydecl{t}{\kschm}{K}{\tau}\tag{Type Declaration}\\
    \end{align*}
    \caption{Type environments}
    \label{grammar:env}
  \end{minipage}\hfill
  \begin{minipage}{0.7\linewidth}
    \begin{mathpar}
      \ruleSDBorrow
      \and
      \ruleSDLam
      \and
      \ruleSDVar
    \end{mathpar}
    \caption{The {\sc Borrow}, {\sc Abs} and {\sc Var} rules}
    \label{selectrules:borrow}
    \label{selectrules:binders}
  \end{minipage}
\end{figure*}

\lang controls the use of variables by supporting new modes of
binding in a type environment $\E$.
Its definition is given in  \cref{grammar:env}.
In addition to standard bindings of type variables to kind schemes,
$\bvar{\tvar}{\kschm}$,  and value bindings, $\bvar{x}{\schm}$, there
are suspended bindings and borrow bindings.
A suspended binding, $\svar{x}{\schm}^n$, indicates that $x$ is
earmarked for a borrowing use in a nested region
marked with $x$ (see \cref{sdtyping:regions}), but
cannot be used directly.
A borrow binding, $\bvar{\borrow{x}}{\borrowty{k}{\schm}}$, replaces
such a suspended binding on entry to the $x$-region. It indicates
that the borrow $\borrow{x}$ can be used directly. The kind $k$
restricts the lifetime of the borrow to the region (see \cref{selectrules:borrow}).

% , either
% through
% linearity and affinity which restrict how variables are shared and ignored,
% or through borrows which allow to circumvent the linearity rules
% in a controlled way.
% In order to check these properties, we introduce several new bindings
% in our typing environments.
% The grammar of type environment (denoted $\E$) is shown in \cref{grammar:env}.

% Environments are also used to encode several linearity-related properties
% through \emph{environment-wide constraints}.
Constraints on an environment control substructural properties by
restricting the types of variables.  The constraint $\Cleq{\E}{k}$
abbreviates $\Cleq\schm k$, for all $\bvar{x}{\schm}$
% $\svar{x}\schm$, and $\bvar{\borrow{x}}{\borrowty{k'}{\schm}}$
in $\E$, which in turn means that $k' \lk k$ where $k'$ is the kind of
the variable's type scheme.
Borrow bindings follow the exact same rules, but suspended bindings
are forbidden in an environment $\E$ constrained like that.
This intuitive explanation is sufficient to understand
the {\sc Abs} and {\sc Var} rules shown in
\cref{selectrules:binders}.

The {\sc Var} rule looks up the type scheme of the variable $x$ in
the environment $\E$
and instantiates it using the substitution $\unif$. The rule also
checks that the other bindings in $\E$ can be safely discarded by
imposing the constraint $\Cleq{\E\Sdel{x}}{\kaff_\infty}$.
It enforces that all remaining bindings (except $x$) are affine or
unrestricted and can therefore be discarded.

The {\sc Abs} rule ensures that the kind annotation on the arrow type
($\tau_2 \tarr{k} \tau_1$) reflects the restrictions on the captured variables.
To do so, the rule imposes the constraint $\Cleq\E k$.
If, for instance, any binding in $\E$ is affine, it gives rise to the
constraint $\Cleq{\kaff_n}{k}$, so that  the arrow kind is at least
affine at nesting level $n$.
Capturing a borrow is perfectly fine: the kind of the borrow is also a
lower bound of the arrow kind $k$ which restricts the closure
to the region of the borrow.
Capturing a suspended binding is forbidden.
% Note that $x$ is \emph{not} included in $\E$: since it's the argument of the
% closure, its use should not induce a capture.




\subsubsection{Copying and Splitting}
\label{sdtyping:split}
\begin{figure*}[tp]
  \centering
  \begin{minipage}{0.49\linewidth}
    \begin{mathpar}
      \ruleSDPair

      \ruleSDRegion
    \end{mathpar}
    % \caption{The {\sc Pair} rule}
    \caption{Selected typing rules}
    \label{sdtyp:pair}
    \label{selectrules:region}
  \end{minipage}\hfill
  \begin{minipage}{0.5\linewidth}
    \centering
    \begin{tabular}
      {@{}>{$}r<{$}@{ $\vdash_e$ }
      >{$}c<{$}@{ $=$ }
      >{$}c<{$}@{ $\ltimes$ }
      >{$}c<{$}r}

      \Cleq{\schm}{\kun_\infty}
      &\bvar{x}{\schm}&\bvar{x}{\schm}&\bvar{x}{\schm}
      &Both\\[2mm]

      {\Cempty}&
      {\bvar{\borrow[\IBORROW]{x}}{\schm}}&
      {\bvar{\borrow[\IBORROW]{x}}{\schm}}&{\bvar{\borrow[\IBORROW]{x}}{\schm}}
      &Borrow\\[2mm]

      {\Cempty}&{\bvar{x}{\schm}}&{\bvar{x}{\schm}}&{\bnone}
      &Left\\
      {\Cempty}&{\bvar{x}{\schm}}&{\bnone}&{\bvar{x}{\schm}}
      &Right\\[2mm]

      {\Cempty}&{\bvar x \schm}&{\svar x \schm^n}&{\bvar x \schm}
      &Susp\\

      {\Cempty}&
      {\bvar{\borrow x} \schm}&{\svar[\IBORROW] x \schm^n}&{\bvar{\borrow x} \schm}
      &SuspB\\

    \end{tabular}
    \caption{Splitting rules for bindings}
    \label{sdtyp:split}
  \end{minipage}
\end{figure*}

The {\sc Pair} typing rule in \cref{sdtyp:pair} demonstrates how \lang
deals with duplication and dropping of values.
The splitting $\lsplit{C}{\E}{\E_1}{\E_2}$ in the rule decomposes the
type environment $\E$ in two parts, $\E_1$ and $\E_2$, which are used
to typecheck the components of the pair.
The constraint $C$ characterizes a valid  splitting.

\cref{sdtyp:split} shows the action of the splitting rules on single
bindings. If $x$'s type is unrestricted, then
the {\sc Both} rule indicates that we can duplicate it.
Similarly, unrestricted borrows can be duplicated according to rule
{\sc Borrow}.
The {\sc Left} and {\sc Right} rules are always applicable and move a binding
either to the left or right environment.
The rules {\sc Susp} and {\sc SuspB} split off suspended bindings to
the left while conserving access to the binding on the right.
A suspended binding can later be turned
into a borrow inside a region. Splitting of suspended bindings is
asymmetric. It must follow the order of execution from left to right,
which means that a resource can be used first as a borrow on the left
and then later as a full resource on the right. The {\sc Susp} rule
works with a full resource while the {\sc SuspB}
rule splits off an shared suspended binding from a borrow.
%
Splitting applies whenever an
expression has multiple subexpressions:  pairs, function applications,
and let bindings. In the
expression
$\letin{a}{\text{create}\ 10\ x}
{\introPair{\region[{}]{\Sone x\IBORROW}{\app{\text{length}}{\borrow[\IBORROW]{a}}}}{a}}$,
the rule {\sc Susp} splits off a borrow from  the resource
\lstinline/a/ to use it in the left component of the pair.
As usual, a borrow cannot be active in the same scope as its resource.
The \emph{region} around its use ensures that the borrow in the left component does not
escape, which brings us to the next topic.



\subsubsection{Regions}
\label{sdtyping:regions}
\begin{figure}[tp]
  % \begin{minipage}{0.4\linewidth}
  %   \centering
  %   \begin{mathpar}
  %     \ruleSDRegion
  %   \end{mathpar}
  %   \caption{The {\sc Region} rule}
  %   \label{selectrules:region}
  % \end{minipage}\hfill
  \begin{minipage}{\linewidth}
    \centering
    % \begin{tabular}
    %   {@{}>{$}r<{$}@{ $\vdash_e$ }
    %   >{$}c<{$}@{ $\rightsquigarrow_n^{x}$ }
    %   >{$}l<{$}
    %   r}

    %   (\kun_n\lk k\lk\kun_\infty)
    %   &{\svar[\IBORROW]{x}{\tau}^n}
    %   &{\bvar{\borrow[\IBORROW]{x}}{\borrowty[\IBORROW] k{\tau}}}
    %   &Immut\\

    %   (\kaff_n\lk k\lk\kaff_\infty)
    %   &\svar[\MBORROW]{x}{\tau}^n
    %   &\bvar{\borrow[\MBORROW]{x}}{\borrowty[\MBORROW] k{\tau}}
    %   &Mut
    % \end{tabular}
    \begin{mathpar}
      \inferrule{
        \entail{C}{(\BORROW_n\lk k) \wedge (k \lk \BORROW_\infty)}\\
        \BORROW\in\left\{\kun,\kaff\right\}
      }{
        \lregion{C}{}
        {\svar[\BORROW]{x}{\tau}^n}
        {\bvar{\borrow[\BORROW]{x}}{\borrowty[\BORROW] k{\tau}}}
      }
    \end{mathpar}
    \caption{Borrowing rules for bindings -- $\lregion{C}{x}{\E}{\E'}$}
    \label{env:rule:borrow}
  \end{minipage}
\end{figure}

Borrowing is crucial to support an imperative programming style.
To guarantee the validity of a borrow, its lifetime must be properly contained in its
ancestor's lifetime. \lang ensures proper nesting of lifetimes by using
regions. The expression $\region{\Sone x\BORROW}{e}$ indicates a
region at nesting level $n$ in which a $\BORROW$-borrow can be taken of $x$.

The typing for a region (see the {\sc Region} rule in \cref{selectrules:region})
replaces suspended bindings by borrow bindings
(\cref{env:rule:borrow}), typechecks the body
of the region, and finally ensures that the borrow does not leak outside.
This last check is done with indices that correspond to the nesting
level of the region. The kind $k$ of the borrow is indexed with the level $n$
corresponding to its region, thanks to the constraint $(\BORROW_n\lk
k)$, and the constraint $\Cleq{\tau}{\klin_{n-1}}$ ensures that
the return type of the region must live at some enclosing, lower level.

As an example, consider the expression $\region{\Sone x\IBORROW}{f(\borrow[\IBORROW]{c})}$
where $c$ is a linear channel in an environment $\E$.
The first step is to check that $\svar[\IBORROW]{c}{\text{channel}}$
is in $\E$.
When entering the region, rule \TirName{Region} imposes
$\lregion{C}{x}{\E}{\E'}$, which defines $\E'$
corresponding to $\E$ where the suspended binding is replaced by the
borrow binding  $\bvar{\borrow[\IBORROW]{c}}{\borrowty[\IBORROW]{k}{\text{channel}}}$.
To constrain the borrow to this region we impose the constraint
$\entail{C}{(\kun_n\lk k) \wedge (k \lk\kun_\infty)}$, which affirms
that the borrow is unrestricted, but can only be used in nesting
levels $n$ and higher.
With that setup we typecheck the body of the region,
$f(\borrow[\IBORROW]{c})$.
The constraint $\Cleq{\tau}{\klin_{n-1}}$ ensures
that the kind of $\tau$ does not contain anything whose kind is
``above level $n$'' and thus confines the borrow to the region
(for instance, $\borrowty[\IBORROW]{\kun_n}{\text{c}}$ has kind
$\kun_n$ and thus cannot be returned).


As it would be cumbersome to markup regions manually, we developed an
algorithm that starts from each borrow, creates a region around it,
and extends it as much as possible while respecting other borrows
and binders. The algorithm (see \cref{regionannot}) also provides the region's level
and variable annotation.
Henceforth, we consider terms with fully annotated regions.



% \subsubsection{Kind checking}

% \TODO{Present this if we have enough space}

% \subsubsection{Pattern matching}

% \TODO{Present this if we have enough space}

% \clearpage
\subsection{Semantics}
\label{sec:sem}
\input{internal-grammar}

\lstMakeShortInline[style=rule,basicstyle=\normalsize\normalfont]@

In this section, we present the dynamics of \lang in big-step
functional
style~\cite{siek13:_type_safet_three_easy_lemmas,DBLP:conf/esop/OwensMKT16,
  DBLP:conf/popl/AminR17}. It is given as a function
@eval \Store \Perm \VEnv i e@
that manipulates the semantic objects defined in
\cref{fig:syntax-internal-language}.
To demonstrate resource handling, the semantics comes with an abstract
notion of linear resources that can be created, destroyed, observed
(through unrestricted borrows), and
updated (through affine borrows).

Expressions $e$ need to be elaborated with some kind and constraint
annotations. Polymorphic functions give rise to elaborated
abstractions which abstract over kind variables $\Multi\kappa$ and
which are tagged with a kind $k$ indicating their usage restriction
(linear, affine, etc). Their use
gives rise to elaborated application where the instantiation of these
kind variables is given. Pairs also come with a kind tag $k$
indicating the usage restriction.

Addresses $\Addr$ are composed of a raw location $\Loc$, which is just
a pointer into a store, and a stack of modifiers that indicates the
borrows that have been taken from the original object. From the raw
location, we may take affine borrows and reborrows. Once we have
taken an unrestricted borrow (from a raw location or a borrowed one),
then we can take further unrestricted borrows from it, but no more
affine ones.

A permission $\Perm$ is a set of addresses. During evaluation it
contains the set of addresses that may be accessed. For each raw
location, there is only ever one address inside of $\Perm$.

A result $r$ is either an address or a constant (e.g., a number). All
non-trivial values are boxed in the sense that they are represented by
the address of their actual content.

A value environment $\VEnv$ is a mapping from variables to results.

A storable $w$ is a particular object that can be stored. There are five
kinds of storable. A poly closure represents a polymorphic
function. It consists of an environment and the components of an
elaborated abstraction. Similarly, a closure represents a monomorphic
function and it elides kind variables and the constraint. A pair
consists of a kind and two results. A resource is just an indirection
to another result and the $\StFreed$ fills a released location.

Finally, the store $\Store$ is a mapping from raw locations to
storables. It comes with a function
@salloc@ of type @store -> storable -> (loc * store)@ such that
@salloc delta@ @w@ allocates a free location in @delta@ and fills it with
storable $w$. It returns the location and the updated store.


The evaluation function is indexed by a step count so that each
invocation is guaranteed to terminate either with an error, a timeout,
or a meaningful result. Hence its return type is a monad
\lstinline/'a sem/ which combines error reporting, timeout, and a
result of type \lstinline/'a/:
\begin{lstlisting}
type 'a sem = Error of string | TimeOut | Ok of 'a
val eval : store -> perm -> venv -> int -> exp -> (store * perm * result) sem
\end{lstlisting}
It evaluates the given expression in the context of an initial store, a
permission to use addresses in the store, a value environment, and a
step count. If successful, it returns the final store, the remaining
permissions, and the actual result.

\input{fig-code}

We give some excerpts of the definition of @eval@ in
\cref{fig:big-step-interpretation} and leave the full
definition for \cref{sec:semant-defin}. The appendix also
contains the semantics
in traditional notation, which does not make the monadic nature of
evaluation explicit.

The definition uses concrete OCaml syntax with some pretty
printing. The pervasive @let*@ operator acts as monadic bind
for the \lstinline/sem/ monad. The function header of @eval@ checks
whether time is up and otherwise proceeds processing the expression.

The @Varinst@ case corresponds to the elaborated application. It
obtains the variable's value, checks that it is a location, checks the
permission (the @let*?@ clause), obtains the storable $w$ at that
location, and checks that it is an STPOLY. Then it updates the
permission: if the STPOLY closure is unrestricted, then the location
remains in the permission set, otherwise it is removed. Finally, we
allocate a new monomorphic closure, add it to the permissions, and
return the pointer as the result along with the updated store and
permissions.

The @App@ case implements function application. Compared to the syntax
it comes with an annotation @sp@ which contains evidence of the
environment splitting in the application rule. This evidence takes the
form of two sets of variables from the domain of @gamma@.

To execute an application, we first apply the splitting to @gamma@ and
evaluate subterm @e_1@ with its part of the environment and the
decremented timer @i'@. The result must be a location that we are
permitted to use. Moreover, there must be a monomorphic STCLOS stored
at that location. The permission to further use this closure is
withdrawn unless the closure is unrestricted. Finally, we evaluate the
argument, then the function body, and return its result.

The @Pair@ case does not present any new features, but it
corresponds to the \TirName{Pair} typing rule.

The @Region@ case implements a region. It obtains the address for @x@,
the suspended binding, and extends it with the intended borrow
$\BORROW$. This extension may fail if we try to take an affine borrow
of an unrestricted borrow. Next, we rebind @x@ to the borrow's
address, extend the permission accordingly, and execute the region's
body.  Finally, we withdraw the permission and return the result.

The @Borrow@ case obtains the address for @x@, checks that it is a
borrow of the correct mode $\BORROW$ and whether it is permitted to
use it. It just returns the address.

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
