\lstMakeShortInline[keepspaces,basicstyle=\small\ttfamily]@
\section{Extensions}

\subsection{Algebraic Datatypes}

Algebraic data types are a staple of functional programming and fit nicely
in our paradigm. Indeed, it is sufficient to ensure  that the kinds of
the constructor arguments are less than or equal to the kind of the datatype.
Hence, it is forbidden to include affine elements in an unrestricted
datatype, whereas the elements in a linear list may be linear or
unrestricted. 
Here is the definition of a datatype for linear lists.

\begin{lstlisting}
type ('a : 'k) llist : lin = Nil | Cons of ('a * 'a llist)
\end{lstlisting}

This extension is implemented in our prototype.

\subsection{Ad-hoc Polymorphism and Borrows}

In our formalization, we use two operators, $\borrow{x}$ and $\reborrow{x}$ to
distinguish between borrows and borrows of borrows.
Such a distinction is inconvenient for programming.
Using a typeclass-like mechanism, we can replace these operators
by a single overloaded operator, $\borrow{x}$, which expects $x$ to be @Borrowable@ and
would then desugar to the more precise operators.
A similar solution is used in Rust through the @Borrow@ and @Defer@
traits.
This approach also enables method calls on objects without
explicit borrows, such as @foo.len()@ where len expects a shared borrow.

Ad-hoc polymorphism fits demonstrably in the \hmx framework of constrained
types and preserves all properties of our language such
as principal type inference. Its soundness is orthogonal to linear types
and has been explored in the literature~\citep{DBLP:conf/fpca/OderskyWW95}.

\subsection{Non-Lexical Lifetimes}

A recent important addition to Rust is the notion of non-lexical lifetimes.
With this feature code is acceptable even if borrowing does not respect
lexical scoping as in this example:

\begin{lstlisting}
let a = &x in
f a;
g (&!x)
\end{lstlisting}

Patterns like this one are dynamically safe because $a$ is not used after
the second line.
Non-lexical lifetimes handle such patterns by removing expressions
that do not mention $a$ from its region; in this example,  the
expression on the last line.
%
In \lang, regions are purely lexical and marked by the
expression $\region{b}{e}$.
During inference, region typing is only done when exiting the region:
we modify the usage environment and introduce a kind constraint to prevent
escaping.

We can thus replace the lexical region by
an annotation on each subexpression indicating which borrowing it is associated
to. When exploring a subexpression, we compare the annotations, and automatically
apply the $\textsc{Region}$ rule when they differ.
%
This approach is equivalent to inlining the $\textsc{Region}$ rule in all the other
rules.

Applied to the program above, only the first two lines would be annotated
to be ``in the region associated with @&x@'', but not the last line.
When typing the sequence, since the annotations are different, we will apply
the region rule to the right hand side.

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
