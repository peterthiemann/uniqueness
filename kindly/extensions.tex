\lstMakeShortInline[keepspaces,basicstyle=\small\ttfamily]@
\section{Limitations and Extensions}

\subsection{Flow sensitivity}

The type system defined so far does not support any
form of flow sensitivity. Therefore, code patterns that rely on
subtle flow-sensitive usage of permissions and linearity will most likely not
typecheck in \lang. For example, the following merge function on linear lists
cannot be expressed directly, because matching against
\lstinline/l1/ and \lstinline/l2/ consumes both lists.

\begin{lstlisting}
let rec merge l1 l2 = match l1, l2 with
  | h1::t1, h2::t2 ->
    if &h1 < &h2 
    then h1::(merge t1 l2) (* Must expand l2 to h2::t2 here *)
    else h2::(merge l1 t2)
  | ....
\end{lstlisting}

Patterns like this require a richer logic, such as provided by
Mezzo~\citep{DBLP:phd/hal/Protzenko14}.
However,
\citet{DBLP:journals/corr/abs-1903-00982} formalize Rust's
notion of non-lexical lifetimes which partially supports such
code patterns. We believe this notion can be adapted to \lang's notion of
regions.

\subsubsection*{Non-Lexical Regions}

The notion of non-lexical lifetimes is 
a recent addition to Rust.
With this feature code is acceptable even if borrowing does not respect
lexical scoping as in this example:

\begin{lstlisting}[numbers=none]
let a = &x in (f a; g &!x)
\end{lstlisting}

This code pattern is dynamically safe because $a$ is not used after
the function call @f a@.
Here, this can be made explicit by transforming
the code to @(let a = &x in f a); g &!x@. However, this is not possible
in programs with branches who uses different dynamic patterns.
Non-lexical lifetimes (NLL) handle such a pattern by removing expressions
that do not mention $a$ from its region; in this example,  NLL removes
the last expression.
%
In \lang, regions are lexical and marked by the
expression $\region{b}{e}$.
During inference, kind constraints prevent escaping from
a region.

To add support for non-lexical lifetimes, we could replace the
lexical region by an annotation on each expression indicating which borrows are
live in this expression.
When exploring a subexpression, we would compare the annotations, and automatically
apply the $\textsc{Region}$ rule when they differ.
%
This approach is equivalent to inlining the $\textsc{Region}$ rule in all the other
rules.

Applied to the program above, only the first two expressions would be annotated
to be ``in the region associated with @&x@'', but not the last expression.
Thanks to these annotations, type checking the sequence would check
that the borrow does not escape the left-hand side (i.e., the second
expression @f a@).

\subsection{Capabilities and Identity}

In \lang the tracking of linearity does
not rely on any notion of ``identity'': the type system cannot specify that two
objects are the same, simply that they share the same usage pattern with
regards to linearity.
A language like Alms~\citep{DBLP:conf/popl/TovP11}, on the other hand,
often relies on a notion of identity to express capabilities.
For instance, the Alms typing
@Array.create : int -> 'a -> \E 'b. ('a, 'b) array@ uses
@'b@ as a  unique identification of the array.
Functions such as @Array.acquire : ('a, 'b) array -> 'b cap@
are used to obtain capabilities to operate on the array.

While such uses are partially covered by borrows and regions,
a notion of identity associated to regions
would enable us to express regions directly in type signatures.
For instance, the @get_eb@ function shown in
\cref{tuto:vector} could be made safe
by creating a restricted inner region on function application,
with the signature:
@&!('k, 'a Array.t) -> int -> \E ('k' < 'k) &!('k', 'a)@


This approach relies on existential types to model identities.
At present, \lang does not support existentials as it would
forgo principal type inference.
However, existentials
are compatible with the HM(X) framework~\citep{DBLP:conf/icfp/Simonet03}
and would make a very desirable addition to \lang. Work on GADTs in
OCaml and Haskell demonstrates
%% PJT: citation?
that existential types can be put to use without compromising
inference in the rest of the language, by integrating unpacking
and pattern matching.

\subsection{Ad-hoc Polymorphism and Borrows}

In our formalization, we use two operators, $\borrow{x}$ and $\reborrow{x}$ to
distinguish between borrows and borrows of borrows.
Such a distinction is inconvenient for programming.
Using a typeclass-like mechanism, we can replace these operators
by a single overloaded operator, $\borrow{x}$, which expects $x$ to be @Borrowable@ and
would then desugar to the more precise operators.
A similar solution is used in Rust through the @Borrow@ and @Defer@
traits.
This approach also enables method calls on objects without
explicit borrows, such as @foo.len()@ where len expects a shared borrow.

Ad-hoc polymorphism fits demonstrably in the \hmx framework of constrained
types and preserves all properties of our language such
as principal type inference. Its soundness is orthogonal to linear types
and has been explored in the literature~\citep{DBLP:conf/fpca/OderskyWW95}.

\subsection{A Richer Region System}

\lang requires that each region is identified by an index drawn from a partial
order that is compatible with the nesting of regions.
This order can be implemented in many ways, including region variables
as often used in algebraic effects systems, existentials, etc.

For simplicity, the formalization uses the concrete implementation with 
natural numbers for indices. The proofs only rely on
the existence of a partial order and could be adapted to one of the
more abstract approaches.
In particular, \lang could reuse regions variables provided by
the ongoing work on effect systems
for OCaml~\cite{DBLP:conf/sfp/DolanEHMSW17}.

\subsection{Standard Features}

\subsubsection{Algebraic Datatypes}

Algebraic data types are a staple of functional programming and fit nicely
in our paradigm. Indeed, it is sufficient to ensure  that the kinds of
the constructor arguments are less than or equal to the kind of the datatype.
Hence, it is forbidden to include affine elements in an unrestricted
datatype, whereas the elements in a linear list may be linear or
unrestricted. 
Here is the definition of a datatype for linear lists.

\begin{lstlisting}
type ('a : 'k) llist : lin = Nil | Cons of ('a * 'a llist)
\end{lstlisting}

This extension is implemented in our prototype.

\subsubsection{Branching constructs}

Our formalization of \lang does not contain branching constructs. As a consequence,
subexpressions are always executed sequentially. Ordering is import
for the splitting relation introduced in \cref{sdtyping}, as it must
coincide with the order of evaluation. To account for borrows and linear
values in different branches, we need a different, straightforward (symmetric) join relation.
Its definition follows immediately from the semantics of borrows and linearity
shown so far and it must be used in the typing rules for branching
constructs such as if-then-else and pattern matching.
This extension is implemented in our prototype.

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
