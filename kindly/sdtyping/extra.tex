\section{Automatic region annotation}
\label{regionannot}


So far, all \lang programs have been fully annotated with regions information.
We now show how to infer these regions annotations based on
optionally-annotated programs.
First, we extend the region annotation to $\region{S}{E}$ where $S$ is
a map from variables to borrow indicator $b$. This annotation, defined below, is equivalent to nested
region annotations for each individual variable.
%
\begin{align*}
  \region{\Sone x\BORROW;S}{e} &= \region{\Sone x\BORROW}{\region{S}{e}}& \region{\emptyset}{e} &= e\\
\end{align*}
%
\begin{figure*}[!tb]
  \centering
  \input{region-annot}
  \caption{Automatic region annotation --- $\RannotT{e}{e'}$}
  \label{fig:region-annotation}
\end{figure*}
%
\Cref{fig:region-annotation} define a rewriting relation $\RannotT{e}{e'}$
which indicates that an optionally annotated term $e$ can be rewritten
as a fully annotated term $e'$.
Through the rule \textsc{Rewrite-Top}, this is defined
in term of an inductively defined relation
$\Rannot{e}{e'}{S}$ where $n$ is the current nesting and $S$ is a set of
variable that are not yet enclosed in a region.
The base cases are constants, variables and borrows.
The general idea is to start from the leaves of the syntax tree, create a
region for each borrow, and enlarge the region as much as possible.
This is implemented by a depth-first walk of the syntax
tree which collects each variable that has a corresponding borrow.
At each step, it rewrites the inner subterms,
consider which borrow must be enclosed by a region now, and
return the others for later enclosing. Binders force immediate
enclosing of the bound variables, as demonstrated in rule \textsc{Rewrite-Lam}.
For nodes with multiple children, we
use a scope merge operator to decide if regions should be placed and where.
This is shown in rule \textsc{Rewrite-Pair}.
The merge operator, written $\getBorrows{B_l}{B_r}{(S_l,S,S_r)}$, takes
the sets $B_l$ and $B_r$ returned by rewriting the subterms
and returns three sets: $S_l$ and $S_r$ indicates the variables
that should be immediately enclosed by a region on the left and right
subterms and $S$ indicates the set of the yet-to-be-enclosed variables.
As an example, the rule \textsc{AnnotRegion-MutLeft} is applied
when there is an immutable borrow and a mutable borrow. In that case, a
region is created to enclose the immutable borrow, while the mutable
borrow is left to be closed later. This is coherent with the rules
for environment splitting and suspended bindings from \cref{sdtyping}.
%
Explicitly annotated regions are handled specially through
rule \textsc{Rewrite-Region}. In that case, we assume that all inner
borrows should be enclosed immediately.



\section{Constraints}
\label{appendix:constraints}
%
\begin{figure}[tb]
  \centering
  \begin{align*}
    C &::= \Cleq{\tau_1}{\tau_2}
        \mid \Cleq{k_1}{k_2}
        \mid C_1 \Cand C_2
        \mid \Cproj{\tvar}{C}
        \mid \Cproj{\kvar}{C}
  \end{align*}
  \caption{The constraint language}
  \label{grammar:constraint}
  % \input{infer/lattice}
  % \caption{Lattice inequalities -- $k \lk_\Lat k'$}
  \input{infer/entails}
  \caption{Base entailment rules -- $\entail{C}{D}$ }
  \label{rules:entail}
\end{figure}

% \newcommand\A{\mathcal A}
% \newcommand\SC{\mathcal S}

Our system is defined in \cref{infer:solving}.
As before, we write $\CL$ for our constraint system for an arbitrary
total bounded lattice $(\mathcal L, \lk_\Lat)$.
Entailment is written $\entail{C}{D}$, where $D$ is a consequence of the
constraints $C$.
We say that $C$ and $D$ are equivalent, written as $C \equivC D$,
when $\entail{C}{D}$ and $\entail{D}{C}$.
Following HM(X), we define a cylindric constraint system as
a system which respects the following properties for any variable $x$:
\begin{align*}
  \entail{C&}{\Cproj{x}{C}}
  &\entail{C}{D} &\implies \entail{\Cproj{x}C}{\Cproj{x}D}\\
  \Cproj{x}{(C\wedge \Cproj{x}D)}&\equivC \Cproj{x}{C} \wedge \Cproj{x}D
  & \Cproj{x}{\Cproj{y}D}&\equivC \Cproj{y}{\Cproj{x}D}
\end{align*}

Furthermore, we define a term rewriting system as a system where, for every
types $\tau$,$\tau'$, there exists an equality predicates $\Ceq{\tau}{\tau'}$
which is symmetric, reflexive, transitive, stable under substitution and such that,
for any predicate $P$:
\begin{align*}
  \entail{\Ceq{x}{y}\wedge \Cproj{x}C \wedge \Ceq{x}{y}&}{C}
  &\subst{x}{\tau}{P} &\equivC \Cproj{x}P \wedge \Ceq{x}{\tau}
                        \text{ where } x\notin\fv{\tau}
\end{align*}
$\CL$ is defined as the smallest cylindric term constraint system that
satisfies the axiom shown in \cref{rules:entail}.
We define  $\Ceq{\tau}{\tau'}$ as $\Cleq{\tau}{\tau'} \wedge \Cleq{\tau'}{\tau}$.
%
We write $\SC$ for the set of solved forms,
which can be used inside type and kind schemes.
We define $\SC$ as $\CL$ quotiented by the relation $\equivC$.
%
The normalization function is described in \cref{infer:solving}.

\subsection{Example of constraint solving and simplification}
\label{solving:example}

\input{infer/exampleconstr}

\subsection{Principal constraint system}

Our goal is to prove that $\CL$ supports all the properties necessary for
principal type inference, as defined by HM(X).
We first prove that constraint solving
does compute normal forms, and that such normal forms are unique.


\begin{lemma}[Normal form]
  \label{lemma:normalform}
  Given a constraint $D\in\CL$, a substitution $\phi$ and
  $(C,\unif) = \normalize{D}{\phi}$,
  then $\phi\leq\unif$,
  $C \equivC \unif D$ and
  $\unif C = C$.
\end{lemma}
\begin{proof}
  % For simplicity, we assume that any substitution has been already applied
  % to $D$ and that $\phi = id$.
  Let us partition $\phi$ into a part which affects type variables,
  $\phi_\tau$, and a part which affects kind variables, $\phi_k$.

  We write $(C^k,\unif_\tau)$ for the result of
  the modified Herbrand unification on $(D,\phi)$ in step (1).
  Herbrand unification computes the most general
  unifier. Our modified Herbrand unification only output additional
  kind constraints for kind on the arrows and does not change
  the result of the unification. Thus, we have
  $\phi_\tau\leq\unif_\tau$,
  $C^k \equivC \unif_\tau D$ and
  $\unif_\tau C^k = C^k$.

  Let $C^{k+}$ be the result after step (2), we trivially have that
  $\fv{C^{k+}} = \fv{C^k}$ and that $C^{k+} \equivC C^k$.

  Let $C^{A}$ and $\unif_k$ be the results after step (4).
  By definition, we have $\unif_k C^{k+} \equivC C^{A}$ and
  $\unif_k C^{A} = C^{A}$. Since $\phi_k$ has already be applied to $C$ before
  unifying the strongly connected components,
  we have that $\phi_k\leq\unif_k$.

  Let $\unif = \unif_\tau \meet \unif_k$. Since $\unif_\tau$ and $\unif_k$
  have disjoint supports,
  we have $C^{A} = \unif_\tau C^{A} \equivC \unif C^{k+} \equivC \unif D$
  and $\unif C^{A} = C^{A}$.
  Furthermore, $\phi_\tau \meet \phi_k \leq \unif_\tau \meet \unif_k$.

  Steps (5) to (9) all preserve the free variables and the equivalence
  of constraints, which concludes.
\end{proof}

\begin{lemma}[Uniqueness]
  Given $(C_1,\unif_1)$ and $(C_2,\unif_2)$ such that
  $\unif_1 C_1 \equivC \unif_2 C_2$, then
  $\normalize{C_1}{\unif_1}$ and $\normalize{C_2}{\unif_2}$
  are identical up to $\alpha$-renaming.
\end{lemma}
\begin{proof}
  In \cref{lemma:normalform}, we have showed that all the steps of the
  normalization procedure preserve equivalence.
  Since $\unif_1 C_1 \equivC \unif_2 C_2$, equivalence between
  the two results of the normalization procedures is preserved for all steps.

  We write $P(C_a)$ if for all $C = (k, k)'$
  such that $\entail{C_a}{C}$ and $\nvdash_eC$,
  we have $C \in {\mathcal R}_a$.

  Let us write $C_1'$ and $C_2'$ for the constraints after step (4). $P(C_1')$ and
  $P(C_2')$ hold. Indeed, since $C_1'$ and $C_2'$ are only composed
  of existential quantifications and kind inequalities, the only rules
  that applies are transitivity and lattice inequalities.
  After step (2) and (5), the associated relations are fully saturated for these
  two rules, hence all inequalities that can be deduced from $C_a'$ are already
  present in the relation.

  The property $P$ is preserved by step (6) since we only remove
  inequalities that involve existentially quantified variables. Such
  inequalities could not be picked in $P$.
  % In (6) we only remove
  % trivial lattice inequalities.

  Let us write $C''_a$ for $a\in\{1,2\}$ the constraints after step (5).
  Since there are no more existential variables,
  we have $C''_a=(k_i,k'_i)_i=\mathcal R''_a$.
  For any $C=(k,k')$ such that $\entail{}{C}$ and $\entail{C''_a}{C}$,
  then $C \in (\leq) \subset {\mathcal R}''_a$.
  Indeed, the only trivial inequalities in our system are equalities of the form
  $(\kvar, \kvar)$, which were removed in step (4) and the lattice inequalities.

  Let us consider $C = (k,k') \in \mathcal R''_1$.
  Since $C''_1\equivC C''_2$, we have $\entail{C''_2}{C}$.
  If $\nvdash_e{C}$, by $P(C''_2)$ we have that
  $C\in R''_2$.
  If $\entail{}{C}$, then $C\in (\leq) \subset R''_2$.
  We conclude that $R''_1 \subset R''_2$.
  By symmetry, $R''_1 = R''_2$ and $C''_1 = C''_2$.

  This equality is preserved by step (7) and (8)
  since the transitive reduction of a directed acyclic graph is unique,
  which concludes.
\end{proof}

We can now prove all the necessary high level properties.

\begin{lemma}
  For all $C\in\mathcal S$, $\entail{C}{x = x}$ implies
  $\entail{}{x = x}$.
\end{lemma}
\begin{proof}
  By definition of $\operatorname{normalize}$, We have $C = \Multi{\Cleq{k}{k'}}$
  such that the underlying relation has no cycles.
  Thus, we can not deduce neither kind nor type equalities from $C$.
\end{proof}

\begin{property}
  $\CL$ is regular, ie, for $x, x'$ two types or kinds,
  $\entail{}{\Ceq{x}{x'}}$ implies
  $\fv{x} = \fv{x'}$
\end{property}
\begin{proof}
  The only equalities possibles are between variables (via symmetry) or
  between constants.
\end{proof}

Finally, we can conclude with all the properties we need for
HM(X):

\begin{theorem}
  $\CL$ has the principal constraint property,
  $\operatorname{normalize}$ computes principal normal forms for $\CL$
  and $\CL$ is regular.
\end{theorem}


This is sufficient to show that $HM(\CL)$ is principal. However,
we do not use HM(X) directly but an extended version with kind inference,
linear and affine types, and borrow.
We extend the proofs of HM(X) to such a system in \cref{appendix:infer}.


\section{Syntax-directed typing}
\label{appendix:sdtyping}

\subsection{Kinding}
%
\begin{figure}[bt]
  \centering
  \input{sdtyping/sd-kinds}
  \caption{Syntax-directed kinding rule --
    $\inferSK{C}{\E}{\tau}{k}$}
  \label{rules:sd-kinding}
\end{figure}

We write $\inferSK{C}{\E}{\tau}{k}$
if $\tau$ has kind $k$ in environment $\E$ under constraints $C$.
The rules are shown in \cref{rules:sd-kinding}.
Kinds and types follow a small calculus with variables ($\tvar$,\dots),
functions (type constructors $\T{t}$), application ($\tapp{t}{\Multi{\tau}}$)
and primitives such as types for arrows ($\tau\tarr{k}\tau'$) and
borrows ($\borrowty{k}{\tau}$).
Kind checking can thus be done in a fairly straightforward, syntax-directed
fashion by simply following
the syntax of the types. Kind arrows can only appear when looking
up the kind scheme of a type constructor $\T t$. Kind arrows are forbidden
in any other contexts.

\subsection{Environments}
\label{typ:extra:envs}

In \cref{sdtyping}, we only gave a partial description of
the splitting and borrowing relations on environments,
$\lsplit C\E\E\E$ and $\lregion C{x}\E\E$.
The complete definitions are shown on \cref{fig:sd-splitting,fig:sd-borrowing}.
All the definitions are made in term of the inference version, which
returns fresh constraints. The solving version then simply
uses entailment, as shown in rule {\sc ESplit-Check} and
{\sc EBorrow-Check}.
The remaining new rules are dedicated to iterating over the environment.

\cref{fig:contraints-environments-types} defines
the rewriting relation on environment constraints,
$\Cleq\E k \Crewrite C$, which rewrites a constraint of the form
$\Cleq\E k$ into $C$. It proceeds by iterating over the environment
and expanding the constraints for each binding.
Suspended bindings are rejected ({\sc ConstrSusp}).
Borrow bindings directly use the annotated kind ({\sc ConstrBorrow}).
Other bindings use the underlying type scheme ({\sc ConstrBinding}).
Type schemes are constrained by first inferring the kind, and then
emitting the constraint ({\sc ConstrSD} and {\sc ConstrI}).


\begin{figure*}[!tb]
  \input{sdtyping/sd-splitting}
  \caption{Splitting ---
    environments $\lsplit C\E{\E_l}{\E_r}$;
    inference $\bsplit C\E{\bm\E_l}{\bm\E_r}$;
    binders $\bsplit Cb{\bm b_r}{\bm b_l}$}
  \label{fig:sd-splitting}
  \input{sdtyping/sd-borrowing}
  \caption{Borrowing ---
    environments $\lregion[n]{C}{x}{\E}{\E'}$;
    inference $\bregion[\bm n]{C}{\bm x}{\E}{\bm\E'}$;
    binders $\bregion[\bm n]{C}{\bm x}{b}{\bm b'}$}
  \label{fig:sd-borrowing}
  \input{sdtyping/sd-environments}
  \caption{Rewriting constraints on environments --- $\bm{\Cleq{\E}{k}}\Crewrite  C$}
  \label{fig:contraints-environments-types}
\end{figure*}

\subsection{Typing}

The rules for syntax-directed typing are shown in \cref{fig:syntax-directed-typing}
and follow the presentation given in \cref{sdtyping}.
As usual in HM type systems, introduction of type-schemes
is included in the {\sc Let} rule via generalization.
We define $\generalize{C}{\E}{\tau} =
(\Cproj{\Multi{\kvar},\Multi{\tvar}}{C},
\forall \Multi{\kvar},\Multi{\tvar}.\qual{C}{\tau})$
where
$\Multi{\kvar},\Multi{\tvar} = (\fv{\tau}\cup\fv{C})\setminus\fv{\E}$.


\begin{figure*}[hbtp]
  \input{sdtyping/sd-typing}
  \caption{Syntax-directed typing rules}
  \label{fig:syntax-directed-typing}
\end{figure*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
