\section{Linearity, Affinity, and Borrows at Work}
\label{motivation}

\lang{} is amenable to a functional resource-passing style as it is
common in functional encodings of session types (e.g.,
\cite{DBLP:journals/jfp/Padovani17}; see also
\cref{sec:session-linearity} in the supplement). But it really shines 
when manipulating mutable resources like buffers or connection pools
using an imperative programming style. 
%
To support this usage pattern of linearity, we rely on
the notion of borrowing \cite{DBLP:conf/popl/BoylandR05}.

\subsection{Imperative programming}
\label{sec:imper-progr}

As a first example, we consider an API for mutable linear arrays
(\cref{sig:array}).
The intention of this API is to safely handle manual allocation and
deallocation of arrays that may contain affine elements.
One would first use \lstinline/create n v/ to create
an (unrestricted) array of size \lstinline/n/ with some value
\lstinline/v/. This value must be unrestricted as it is duplicated to
initialize all array elements. Using the \lstinline/map/ function we
can transform the unrestricted elements into linear (affine)
ones. This array can be processed further using \lstinline/map/ (or \lstinline/set/ if
affine). The \lstinline/get/ function only applies if the element type
is unrestricted as one element is duplicated. The \lstinline/length/
function applies anytime. Before \lstinline/free/ing the array the elements must be
affine, again.

To manage the different kinds of accessing the array we distinguish between constructors, destructors,
observers, and mutators.
Constructors and destructors like \lstinline/create/ and \lstinline/free/ manipulate the whole
array. As with channels in \cref{sec:session-linearity},
\lstinline/create/ yields a linear resource which is consumed by \lstinline/free/.
During the lifetime of the array resource \lstinline/a/, we can split
off \emph{shared borrows} \lstinline/&a/ that provide a read-only
view or \emph{exclusive borrows} \lstinline/&!a/ for read-write views.
Observer functions such as \lstinline/length/ and \lstinline/get/ expect an shared borrow
argument, mutator functions such a \lstinline/set/ expect
a exclusive borrow.

Each borrow is tied to a region whose lifetime is properly
contained in the lifetime of the resource.
In a region, we can split off as many shared borrows as we like
from a resource, but we can take only one exclusive borrow. In a
subsidiary region, we can take further shared borrows from any
borrow or we can take a exclusive borrow from a exclusive borrow from a
enclosing region. Borrows are confined to their regions. Inside the region,
shared borrows are unrestricted (\lstinline/un/) whereas exclusive
borrows are affine (\lstinline/aff/).

The code in \cref{ex:array} demonstrates a use of the API to create an
array of Fibonacci numbers. After creation of the array, we can see
that the presence of a borrow prevents access to the ``raw''
resource inside the borrow's region. In \cref{ex:array:get} of the
example, there are two shared borrows in the same
expression, which forms a region by itself. These borrows are split
off the exclusive borrow used in \cref{ex:array:set}, which belongs to
the next enclosing region.
Finally, the code returns the whole array in \cref{ex:array:return},
which is possible because none of the borrows are in scope anymore.

\begin{figure}[tp]
  \centering
  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
module Array : sig
  type ('a : 'k) t : lin
  val create : ('a : un) => int -> 'a -> 'a t
  val free : ('a : aff) => 'a t -> unit
  val length : &('a t) -> int
  val get : ('a : un) => &('a t) * int -> 'a
  val set : ('a : aff) => &!('a t) * int * 'a -> unit
  val map : (&'a -> 'b) -> &('a t) -> 'b t
end
\end{lstlisting}
    \vspace{-15pt}
    \caption{Affine arrays}
    \label{sig:array}
  \end{subfigure}

  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get (&a, i-1) + get (&a, i-2) in(*@\label{ex:array:get}*)
    set (&!a, i, x)(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \vspace{-10pt}
    \caption{Example of use of linear arrays}
    \label{ex:array}
\begin{lstlisting}[firstnumber=2]
  let a = create n 1 in
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |} done;
\end{lstlisting}
    \vspace{-10pt}
    \caption{Excerpt of \cref{ex:array} with explicit regions}
    \label{ex:array:region}
  \end{subfigure}
\end{figure}

\cref{ex:array:region} uses braces as in \lstinline/{| ... |}/ to
explicitly state the regions of the example in \cref{ex:array}.  One
region consists of the header expression of the \lstinline/let/ in
\cref{ex:array:region:get}. It is contained in another region that
comprises the body of the \lstinline/for/ loop. \lang guarantees that borrows
never escape the smallest enclosing region. It employs a system of
\emph{indexed kinds} like \lstinline{aff_r} and \lstinline{un_r} where
$r$ is a positive integer that corresponds to the lexical nesting
depth of regions. For instance, the type of \lstinline{&!a} in
\cref{ex:array:set} has kind \lstinline{aff_1} whereas the type of
\lstinline{&a} in \cref{ex:array:region:get} has kind
\lstinline{un_2} and the typing of its region is such that types with
kind indexes greater than or equal to $2$ cannot escape.

In \cref{ex:array:region:get} of the example, there is no danger of \lstinline/&a/ escaping because it
is consumed in the calls to \lstinline/get/.
Region annotations are automatically inserted using
syntactic cues such as borrows and binders (see
\cref{regionannot}).  Users may manually insert regions to further restrict the range of a
borrow. In practice, region annotations are
rarely needed with common programming idioms.
% All regions for the examples in this section have been inferred.


% \begin{figure}
%   \centering
%   % \begin{subfigure}{0.6\linewidth}
% \begin{lstlisting}
% let mk_fib_array n =
%   let a = create n 1 in
%   for i = 2 to n - 1 do {|
%     let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
%     set &!a i x
%   |}
%   done;
%   a(*@\label{ex:array:return}*)
% # mk_fib_array : int -> int Array.t
% \end{lstlisting}
%     \caption{Example from \cref{ex:array} with explicit regions}
%     \label{ex:array:region}
%   % \end{subfigure}
% \end{figure}




\subsection{Hybrid programming style}

Recently introduced persistent data structures
permit transient mutations where
non-linear uses lead to degraded performance
\cite{DBLP:conf/ml/ConchonF07} or to
dynamic and static checks \cite{DBLP:journals/pacmpl/Puente17}.
In particular, persistent Hash-Array-Mapped-Tries (HAMT) have been used with similar
APIs in several non-pure functional languages (OCaml, Clojure, \dots).
Affine types help formalize the performance contract between the programmer
and the library, while borrows avoid the need to thread state explicitly,
as usually required by an API for immutable data types.
%

In this section, we present
a safe API for persistent arrays that support both immutable and mutable features,
and use it to implement a backtracking Sudoku solver.
% show how \lang allows us to define
The Sudoku solver maintains an array to represent the state of
the game and uses backtracking when there are several choices to proceed.
The use of backtracking suggests a persistent data structure for the array.
However, only changes that correspond to a choice point need to use
the persistence mechanism, others may be implemented as
cheap in-place mutations.

\cref{sig:hybarray} contains an API \lstinline/HybArray/
that enables using mutable and immutable modifications to
the board through affine types and borrows.
The signature differs slightly from the \lstinline/Array/
signature. For simplicity, the array elements are unrestricted, but
the structure itself remains linear so as to be implemented in terms of \lstinline/Array/.
The in-place mutation function \lstinline/set_mut/ with type
\lstinline/&!('a t) * int * 'a -> unit/ works on a exclusive borrow  whereas the persistent
\lstinline/set/ operation has type \lstinline/&('a t) * int * 'a -> 'a t/. It
takes an shared borrow because it only reads from the
argument array, but returns a fresh,  modified structure.
The code in \cref{ex:cow} contains a very simple implementation of
\lstinline/HybArray/ that represents hybrid arrays
as regular arrays and uses copy-on-write for persistent
modifications. The function
\lstinline/mapi : (int -> &'a -> 'b) -> &('a t) -> 'b t /
is a simple variation on \lstinline/Array.map/ where the mapping function
takes the position of the element.
% A more elaborate implementation could use persistent arrays
% \cite{DBLP:conf/ml/ConchonF07}.


\begin{figure}[tp]
  \centering
  \begin{subfigure}{1\linewidth}
\begin{lstlisting}
module type HybArray = sig
  type ('a : un) t : lin
  val create : int -> 'a -> 'a t
  val free : 'a t -> unit
  val length : &('a t) -> int
  val get : &('a t) * int -> 'a
  val set : &('a t) * int * 'a -> 'a t
  val set_mut : &!('a t) * int * 'a -> unit
end
\end{lstlisting}
    \vspace{-15pt}
    \caption{Signature}
    \label{sig:hybarray}
  \end{subfigure}

  \begin{subfigure}{1\linewidth}
\begin{lstlisting}
module Cow : HybArray = struct
  include Array
  let set (a, i0, x0) =
    Array.mapi (fun i x -> if i = i0 then x0 else x) a
  let set_mut = Array.set
end
\end{lstlisting}
    \vspace{-15pt}
    \caption{Implementation using copy-on-write}
    \label{ex:cow}
  \end{subfigure}
  \caption{Hybrid arrays}
\end{figure}

Our implementation of a Sudoku solver (\cref{ex:sudoku}) performs
modifications that correspond to choice points using \lstinline/set/,
which makes it trivial to come back to the previous version
of the array, while other modifications use \lstinline/set_mut/, which
forbids uses of the previous version.

The board is represented as a 2D-matrix (\cref{line:boardtype}), where
the \lstinline/Matrix/ type uses the same API as \lstinline/HybArray/
but with two indices.
Each cell contains an integer set that represent admissible solutions so far.
The Sudoku solver iterates over the cells and tries each possible solution (\cref{line:try_solution}).
When a value is picked for the current cell, we create a choice point,
change the cell with an immutable modification (\cref{line:immutset}), and propagate
the changes with the \lstinline/propagate/ function.
The \lstinline/propagate/ function uses direct mutation through a
exclusive borrow of the matrix as it need not preserve the previous
version of the board.
The implementation of \lstinline/propagate/ is split into three parts
for lines, columns, and square, which are all very similar to function
\lstinline/propagate_lines/ (\cref{line:propline}).

The typing ensures that the mutations do not compromise the state at
the choice point, because they operate on a new state \lstinline/new_g/ created for one
particular branch of the choice.
In particular,
since the \lstinline/set/ function only requires an unrestricted shared borrow,
\lstinline/try_solution/ can captures the borrow \lstinline/&g/
while staying unrestricted.
This also make \lstinline/try_solution/ itself bound to the same
region as \lstinline/&g/. In this example, our region inference
will place the region exactly at the \lstinline/begin//\lstinline/end/
scope.
This allows us to use \lstinline/try_solution/ in
the iteration loop on \cref{line:iter}.
Since \lstinline/&g/ is unrestricted, we could even use a parallel iteration
instead of a sequential one.
As \lstinline/g/ is linear we must free it before returning,
in \cref{line:free:g}, outside of the region.

While presented for copy-on-write arrays, the API
can easily be adapted to other persistent data structures with
transient mutability such as Relaxed-Radix Balance Vectors (RRB) \cite{DBLP:journals/pacmpl/Puente17}
or persistent HAMTs \cite{bagwell2001ideal,clojurehamt} to provide  a
convenient programming style without compromising performance.

\begin{figure}
  \centering
  \lstinputlisting[linerange=1-31]{code/sukodu.affe}
    \vspace{-15pt}
  \caption{Excerpt of the Sudoku solver}
  \label{ex:sudoku}
\end{figure}

% \subsection{Type abstraction and linearity violations}

% While linearity allows to verify many properties, it also prevents
% the implementation of functions that are nevertheless safe. Rust addresses this
% issue through the \lstinline/unsafe/ construct, which allows to locally
% ignore linearity constraints. This is essential to build basic
% functions such as splitting strings.
% %
% \lang allows to partially emulate this behavior using type abstraction
% as provided by ML modules.
% In particular, data types can be internally defined as unrestricted but exposed
% as affine.

% \TODO{Show example with arrays}

\subsection{Local data-structures with regions}
\label{tuto:pool}

% We have seen that borrows are limited to a region.
In the examples so far, regions do not appear in type signatures.
But for certain programming idioms, we want to extend the scope of a
region across a function boundary. As an example,
we present an interface and implementation of a pool of linear resources where the
extended scope of the region enforces proper use of the resources.

\cref{intf:pool} contains the interface of the \lstinline/Pool/ module.
A pool is parameterized by its content. The kind of the pool
depends on the content: linear content implies
a linear pool while unrestricted content yields an unrestricted pool.
The functions \lstinline/Pool.create/ and \lstinline/Pool.consume/
build/destroy a pool given creators/destructors for the elements
of the pool.
The function \lstinline/Pool.use/ is the workhorse of the API, which
borrows a resource from the pool to a callback.
It takes a shared borrow of a pool (to enable concurrent access) and a
callback function.
The callback receives a exclusive borrow of an arbitrary resource from the pool.
The typing of the callback ensures
that this borrow is neither captured nor returned by the function.

This encapsulation is implemented with a universally quantified \emph{kind index variable} $r$.
The signature prescribes the type \lstinline/&!(aff_r1,'a_1 )/ for the
exclusive borrow of the resource with an affine kind at region nesting $r+1$. The return
type of the callback is constrained to kind \lstinline/'k_2 <= aff_r/
so that the callback certainly cannot return the borrowed argument.
In a specific use of \lstinline/Pool.use/, the index $r$ gets unified
with the current nesting level of regions so that the region for the
callback effectively gets ``inserted'' into the lexical nesting at the callsite.

\cref{ex:pool} shows a simple example of using the \lstinline/Pool/ module.

The implementation in \cref{impl:pool} represents a bag of resources
using a concurrent queue with atomic add and remove operations.
The implementation of the \lstinline/Pool.create/ and \lstinline/Pool.consume/
functions is straightforward.
The function \lstinline/Pool.use/ first draws
an element from the pool (or creates a fresh element),
passes it down to the callback function \lstinline/f/, and returns
it to the pool afterwards.
For clarity,
we explicitly delimit the region in \cref{line:pool:region} to ensure that
the return value of \lstinline/f &!o/ does not capture \lstinline/&!o/.
In practice, the type checker inserts this region automatically.

\begin{figure}[tp]
  \centering
  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
type ('a:'k) pool : 'k

create : (unit -> 'a) -> 'a pool
consume : ('a -> unit) -> 'a pool -> unit
use : ('a_1:'k_1),('a_2:'k_2),('k_2 <= aff_r) =>
  &('a_1 pool) -> (&!(aff_r1,'a_1) -{lin}> 'a_2) -{'k_1}> 'a_2
\end{lstlisting}
    \vspace{-10pt}
    \caption{Interface}
    \label{intf:pool}

\begin{lstlisting}
(* Using the pool in queries. *)
let create_user pool name =
  Pool.use &pool (fun connection ->
    Db.insert "users" [("name", name)] connection)

let uri = "postgresql://localhost:5432"
let main users =
  (* Create a database connection pool. *)
  let pool = Pool.create (fun _ -> Db.connect uri) in
  List.parallel_iter (create_user &pool) users;
  Pool.consume (fun c -> Db.close c)
\end{lstlisting}
    \vspace{-10pt}
    \caption{Example of use}
    \label{ex:pool}
  \end{subfigure}

  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
type ('a:'k) pool : 'k = {
  spawn : unit -> 'a ;
  queue : 'a CQueue.t;
}

let create spawn =
  { spawn ; queue = CQueue.create () }
let consume f c =
  CQueue.iter f c.queue

let use { spawn ; queue } f =
  let o = match CQueue.pop &queue with
    | Some x -> x
    | None () -> spawn ()
  in
  let r = {| f &!o |} in(*@\label{line:pool:region}*)
  Queue.push o &queue;
  r
\end{lstlisting}
    \vspace{-15pt}
    \caption{Implementation}
    \label{impl:pool}
  \end{subfigure}

  \caption{The \texttt{Pool} module}
  \label{fig:pool}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
