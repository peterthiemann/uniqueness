\section{Linearity, Affinity, and Borrows at Work}

\TODO{really good examples. first linearity/affinity (files?), then
  something with borrows (functional arrays), and then something
  really spaced out that pushes the limit}

\subsection{A session on linearity}

A classical example of linearity at work are to control the uses of resources such
as files or network handles.
%
Session types, notably, allow to statically type check protocols.
For instance, the type \lstinline{!int.!int.?int.end} represent a session
where the program must send two integers, receive an integer, then end the session.
%
In this context, it is essential that channels
are used linearly, since every use of the channel
will make the protocol progress and change the type of the channel.

Session types are usually defined with the following operators:

\begin{center}
  \begin{tabular}{r l}
    $\tau ! \mathcal S$ & Send a value of type $\tau$ then continue with protocol $S$.\\
    $\tau ? \mathcal S$& Receive a value of type $\tau$ then continue with protocol $S$.\\
    $\mathcal S \oplus \mathcal S'$& Choose between protocols $S$ and $S'$.\\
    $\mathcal S \operatorname{\&} \mathcal S'$& Offer a choice between protocols $S$ and $S'$.
  \end{tabular}
\end{center}

It is well known that binary session types can be embedded into ML languages
\cite{DBLP:journals/jfp/Padovani17}. We can easily
embed session types in our language and provide the following API:
%
\begin{lstlisting}
type 'S st : lin
val receive: ('a ? 'S) st -> 'a * 'S st
val send : ('a:'k). 'a -> ('a ! 'S) st -{'k}> 'S st
val create : unit -> 'S st * (dual 'S) st
val close : end st -> unit
\end{lstlisting}



\TODO{Explain}

We can then use these primitives to implement a simple addition service.
We do not need any extra linearity annotations in the code: the fact
that the \texttt{st} type is declared as linear is sufficient.
In the case below, \lstinline{add_service} is inferred to be of type
\lstinline{(int ! int ! int ? end) st -> unit}

\begin{lstlisting}
let add_service ep =
  let x, ep = receive ep in
  let y, ep = receive ep in
  let ep = send (x + y) ep in
  close ep
# add_service : (int ! int ! int ? end) st -> unit
\end{lstlisting}

The following code then acts as a client, by sending two messages
and receiving the result.
This code is polymorphic in both argument and return types and could thus
be used to any binary operator.
%
\begin{lstlisting}
let op_client ep x y =
  let ep = send x ep in
  let ep = send y ep in
  let result, ep = receive ep in
  close ep;
  result
# op_client : ('a_1 ? 'a_2 ? 'b ! end) st -> 'a_1 -{lin}> 'a_2 -{lin}> 'b
\end{lstlisting}
% The actual answer from the typechecker looks like this:
% # ('m2:^k2), ('m1:^k1).
% # (^k1 < ^k) & (lin < ^k) =>
% # ('m1 ?'m2 ? 'result ! end) st -> 'm1 -{lin}> 'm2 -{^k}> 'result

In addition, this function can be partially
applied to a channel. Since the closure returned by such a partial
application captures the channel, it can only be used once.
This is reflected by the arrow, \lstinline/-{lin}>/, which is the
type of functions that can only be used once.
The general form of arrows types in \lang is \lstinline/-{k}>/, where
\lstinline/kk/ is an arbitrary kind that describes the behavior of
underlying closure.
For convenience, we shorten \lstinline/-{un}>/ as \lstinline/->/.
Note again that the linearity on the arrows was inferred without
any annotation from the user. In fact, the only difference between the code
presented so far and the examples by
\citet{DBLP:journals/jfp/Padovani17}
is the kind annotation on the type definition of \lstinline/st/.

\TODO{more details?}

Finally, we can compose both server and client.
Failure to fully consume either \lstinline/a/ or \lstinline/b/
would result in a type error.
\begin{lstlisting}
let main1 () =
  let (a, b) = create () in
  add_service a;
  op_client b 1 2
# main : unit -> int
\end{lstlisting}


% \begin{figure}
%   \centering
%   \begin{lstlisting}
% val select : ('S st -{'k}> 'a) -> 'a ot -{'k}> ('S dual) st
% val branch : 'm it -> 'm
%   \end{lstlisting}
%   \caption{Session primitives}
%   \label{api:session}
% \end{figure}

\subsection{Imperative programming}

The programming style used for channels so far is
appropriate for purely functional code.
This style is however fairly bothersome in mutable contexts.
%
To make linearity easier to use for imperative programming, we rely on
{\em borrows}. We present a typical API for mutable affine arrays
in \cref{sig:array} and an example of use in \cref{ex:array}.
We can distinguish three type of operations. Firstly,
function that manipulate the whole
array such as \lstinline/create/ and \lstinline/free/, and behaves exactly
like the functions on channel presented in the previous section.
Second, read-only functions such as \lstinline/get/
manipulates \emph{immutable} borrows. An immutable borrow over array \lstinline/a/
is introduced with \lstinline/&a/ and represent a read-only view of the array.
Finally, mutable functions, such as \lstinline/set/ manipulate
a \emph{mutable borrow}. Mutable borrows, introduced with \lstinline/&!a/
represent a read-write view of the array.

Multiple immutable borrows can be used concurrently and are considered
unrestricted (\lstinline/un/).
A mutable borrow is exclusive, and considered affine (\lstinline/aff/).
Furthermore, any borrow prevents access to the ``raw'' access
as long as they are in use. In \cref{ex:array}, on \cref{ex:array:get},
two immutable borrows are used in the same expression. Once this operation
is done, the borrows are not used anymore, which allows us to take
an exclusive immutable borrow to mutate the array on \cref{ex:array:set}.
Finally we can return the whole array on \cref{ex:array:return} since
none of the borrows are used anymore.

\begin{figure}
  \centering
  \begin{subfigure}{0.48\linewidth}
\begin{lstlisting}
module Array : sig
  type ('a : un) t : aff
  
  val create : ('a : un) => int -> 'a -> 'a t
  val free : 'a t -> unit

  val length : &('a t) -> int

  val get : &('a t) * int -> 'a
  val set : &!('a t) * int * 'a -> unit
end
\end{lstlisting}
    \caption{Affine primitives}
    \label{sig:array}
  \end{subfigure}\hfill
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get &a (i-1) + get &a (i-2) in(*@\label{ex:array:get}*)
    set &!a i x(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \caption{Example of use of affine arrays}
    \label{ex:array}
  \end{subfigure}
\end{figure}

Naturally, \lang also checks that borrows do not escape their point
of use through {\em syntactic regions}. The example
above is reproduce in \cref{ex:array:region} with
regions explicitly delimited by \lstinline/{| ... |}/.
\lang ensures that borrows never escape the smallest enclosing
region.
For instance, On \cref{ex:array:region:get}, \lstinline/&a/ does
not escape the region since the borrow is not captured, and the
region only return integers.
Regions annotations are automatically inserted by \lang using
syntactic information such as borrows and binders.
Users can also annotate regions manually to further restrict the range
of a borrow. In practice, we have found that regions
annotations are very rarely needed in common imperative usage.


\begin{figure}
  \centering
  % \begin{subfigure}{0.6\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |}
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \caption{Example from \cref{ex:array} with explicit regions}
    \label{ex:array:region}
  % \end{subfigure}
\end{figure}



\begin{figure}
  \centering
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
let for f a  = 
  let n = Array.length &a in
  let rec loop f a i = 
    if i < n then (
      f &!a i;
      loop f &!a (i+1)
    )
  in
  loop f &!a 0
# Borrowed m ('a Array.t) tt =>
  (tt -> int -> unit) -> tt -> unit
\end{lstlisting}
    \caption{For loop function for affine arrays}
    \label{ex:array}
  \end{subfigure}
\end{figure}

\section{Hybrid programming styles}

While purely functional data-structure present numerous advantages in term
of correctness and ease of use, they sometimes offer worse performances
than their imperative counterpart. On the other hand, reasoning about imperative
data-structure in the context of sharing is notoriously difficult.
%
In this section, we show how linearity and borrowing allows us to define
a safe API for hybrid arrays that support both immutable and mutable features,
and how it can be used to implement a backtracking sudoku solver.



\begin{figure}
  \centering
  \begin{subfigure}{0.48\linewidth}
\begin{lstlisting}
module type HybArray = sig
  type ('a : un) t : aff
  
  val create : ('a : un) => int -> 'a -> 'a t
  val free : 'a t -> unit

  val length : &('a t) -> int
  val get : &('a t) * int -> 'a

  val set : &('a t) * int * 'a -> 'a t
  val set_immut : &!('a t) * int * 'a -> unit
end
\end{lstlisting}
    \caption{Signature}
    \label{sig:hybarray}
  \end{subfigure}\hfill
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
module Cow : HybArray = struct
  include Array

  let set (a, i, x) =
    let f k =
      if k = i then x else Array.get (a,k)
    in
    create (length a) f
  
  let set_mut = Array.set
end
\end{lstlisting}
    \caption{Implementation using copy-on-write}
    \label{ex:cow}
  \end{subfigure}
  \caption{Hybrid arrays -- signature and example implementation}
\end{figure}




\begin{figure}
  \centering
\begin{lstlisting}[multicols=2]
type board = IntSet.t Mat.t

let propagate_line i0 j0 g n =
  for j = j0+1 to size - 1 do
    let cell = Mat.get &g (i0 , j) in
    let cell' = IntSet.remove n cell in
    Mat.set_mut &!g (i0, j) cell'
  done

let propagate i j g n =
  propagate_line i j &!g n;
  propagate_column i j &!g n;
  propagate_square i j &!g n

let rec solve i j g =
  match is_solved &g with
  | true -> Mat.print &g
  | false ->
    let (new_i, new_j) = next_pos (i,j) in
    let try_solution n =
      let new_g = 
        Mat.set &g (i,j) (singleton n) in
      propagate i j &!new_g n;
      if is_valid &new_g when
        solve new_i new_j new_g
    in
    let cell = Mat.get &g (i,j) in
    IntSet.iter try_solution cell
\end{lstlisting}
  \caption{Chosen excerpt from the sudoku solver}
  \label{ex:cow}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
