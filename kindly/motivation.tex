\section{Linearity, Affinity, and Borrows at Work}

\TODO{really good examples. first linearity/affinity (files?), then
  something with borrows (functional arrays), and then something
  really spaced out that pushes the limit}

\subsection{A session on linearity}

A classical example of linearity at work are to control the uses of resources such
as files or network handles.
%
Session types, notably, allow to statically type check protocols.
For instance, the type \lstinline{!int.!int.?int.end} represent a session
where the program must send two integers, receive an integer, then end the session.
%
In this context, it is essential that channels
are used linearly, since every use of the channel
will make the protocol progress and change the type of the channel.

Session types are usually defined with the following operators:

\begin{center}
  \begin{tabular}{r l}
    $\tau ! \mathcal S$ & Send a value of type $\tau$ then continue with protocol $S$.\\
    $\tau ? \mathcal S$& Receive a value of type $\tau$ then continue with protocol $S$.\\
    $\mathcal S \oplus \mathcal S'$& Choose between protocols $S$ and $S'$.\\
    $\mathcal S \operatorname{\&} \mathcal S'$& Offer a choice between protocols $S$ and $S'$.
  \end{tabular}
\end{center}

It is well known that binary session types can be embedded into ML languages
\cite{DBLP:journals/jfp/Padovani17}. We can easily
embed session types in our language and provide the following API:
%
\begin{lstlisting}
type 'S st : lin
val receive: ('a ? 'S) st -> 'a * 'S st
val send : ('a:'k). 'a -> ('a ! 'S) st -{'k}> 'S st
val create : unit -> 'S st * (dual 'S) st
val close : end st -> unit
\end{lstlisting}



\TODO{Explain}

We can then use these primitives to implement a simple addition service.
We do not need any extra linearity annotations in the code: the fact
that the \texttt{st} type is declared as linear is sufficient.
In the case below, \lstinline{add_service} is inferred to be of type
\lstinline{(int ! int ! int ? end) st -> unit}

\begin{lstlisting}
let add_service ep =
  let x, ep = receive ep in
  let y, ep = receive ep in
  let ep = send (x + y) ep in
  close ep
# add_service : (int ! int ! int ? end) st -> unit
\end{lstlisting}

The following code then acts as a client, by sending two messages
and receiving the result.
This code is polymorphic in both argument and return types and could thus
be used to any binary operator.
%
\begin{lstlisting}
let op_client ep x y =
  let ep = send x ep in
  let ep = send y ep in
  let result, ep = receive ep in
  close ep;
  result
# op_client : ('a_1 ? 'a_2 ? 'b ! end) st -> 'a_1 -{lin}> 'a_2 -{lin}> 'b
\end{lstlisting}
% The actual answer from the typechecker looks like this:
% # ('m2:^k2), ('m1:^k1).
% # (^k1 < ^k) & (lin < ^k) =>
% # ('m1 ?'m2 ? 'result ! end) st -> 'm1 -{lin}> 'm2 -{^k}> 'result

In addition, this function can be partially
applied to a channel. Since the closure returned by such a partial
application captures the channel, it can only be used once.
This is reflected by the arrow, \lstinline/-{lin}>/, which is the
type of functions that can only be used once.
The general form of arrows types in \lang is \lstinline/-{k}>/, where
\lstinline/kk/ is an arbitrary kind that describes the behavior of
underlying closure.
For convenience, we shorten \lstinline/-{un}>/ as \lstinline/->/.
Note again that the linearity on the arrows was inferred without
any annotation from the user. In fact, the only difference between the code
presented so far and the example by
\citet{DBLP:journals/jfp/Padovani17}
is the kind annotation on the type definition of \lstinline/st/.

\TODO{more details?}

Finally, we can compose both server and client.
Failure to fully consume either \lstinline/a/ or \lstinline/b/
would result in a type error.
\begin{lstlisting}
let main1 () =
  let (a, b) = create () in
  add_service a;
  op_client b 1 2
# main : unit -> int
\end{lstlisting}


% \begin{figure}
%   \centering
%   \begin{lstlisting}
% val select : ('S st -{'k}> 'a) -> 'a ot -{'k}> ('S dual) st
% val branch : 'm it -> 'm
%   \end{lstlisting}
%   \caption{Session primitives}
%   \label{api:session}
% \end{figure}

\subsection{Hybrid paradigms}

The programming style used for channels so far, which are passed back
and forth between functions, is appropriate for purely functional code.
This style is however fairly bothersome in imperative contexts.

ML languages are often characterised by their hybrid programming style
that mixes functional styles with imperative side effects. In
this context, the programming style used for channels is fairly verbose.
Similarly to Rust, we use {\em borrows} to allow easy imperative
programming with linear and affine resources.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
