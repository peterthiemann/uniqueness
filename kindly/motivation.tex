\section{Linearity, Affinity, and Borrows at Work}
\label{motivation}

\lstMakeShortInline[keepspaces,basicstyle=\small\ttfamily]@

\lang{} is amenable to a functional resource-passing style
common in functional encodings of session types (e.g.,
\cite{DBLP:journals/jfp/Padovani17}; see also
\cref{sec:session-linearity} in the supplement). But it really shines 
when manipulating mutable resources like buffers or connection pools
using a mixed functional and imperative programming style.
%
To support this usage pattern of linearity, we rely on
the notion of borrowing \cite{DBLP:conf/popl/BoylandR05} which
we demonstrate through a series of examples:
\begin{itemize}
\item An API for linear arrays to demonstrate simple borrowing and imperative programming.
\item
  A backtracking Sudoku solver to demonstrate
  \lang's ability to build safe hybrid functional/imperative data-structures.
\item A pool of linear objects to demonstrate advanced use of regions.
\end{itemize}

\subsection{Imperative programming with linear arrays}
\label{sec:imper-progr}

The API for mutable linear arrays (shown in \cref{sig:array})
aims to safely handle manual allocation and
deallocation of arrays that may contain affine elements.
One would first use @create n v@ to create
an (unrestricted) array of size @n@ initialized with value
@v@. This value must be unrestricted as it is duplicated to
initialize all array elements. Using the @map@ function we
can transform the unrestricted elements into linear (affine)
ones. This array can be processed further using @map@ (or @set@ if
affine). The @get@ function is only applicable if the element type
is unrestricted as one element is duplicated. The @length@
function is always applicable. To @free@ an array the elements must be
affine.

To manage the different kinds of accessing the array we distinguish between constructors, destructors,
observers, and mutators.
Constructors and destructors like @create@ and @free@ manipulate the whole
array. %As with channels in \cref{sec:session-linearity},
The constructor
@create@ yields a linear resource which is consumed by @free@.
During the lifetime of the array resource @a@, we can split
off \emph{shared borrows} @&a@ that provide a read-only
view or \emph{exclusive borrows} @&!a@ for read-write views.
Observer functions such as @length@ and @get@ expect an shared borrow
argument, mutator functions such a @set@ expect
a exclusive borrow.

Each borrow is tied to a region whose lifetime is properly
contained in the lifetime of the resource.
In a region, we can split off as many shared borrows of a resource as
we like, but we can take only one exclusive borrow. In a 
subsidiary region, we can take shared borrows of any
borrow or we can take an exclusive borrow of an exclusive borrow from an
enclosing region. Borrows are confined to their regions. Inside the region,
shared borrows are unrestricted (@un@) whereas exclusive
borrows are affine (@aff@).

The code in \cref{ex:array} demonstrates a use of the API to create an
array of Fibonacci numbers as the programmer would write it. After
creation of the array, the presence of a borrow in the for loop
prevents access to the ``raw'' resource inside the loop's
body. \cref{ex:array:get} of the example contains two shared borrows
in the same expression, which forms a region by itself. These borrows
are split off the exclusive borrow used in \cref{ex:array:set}, which
belongs to the next enclosing region corresponding to the loop body.
The whole array can be returned in \cref{ex:array:return} because  the
borrows are no longer in scope. 

\begin{figure}[tp]
  \centering
  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
module type ARRAY = sig
  type ('a : 'k) t : lin
  val create : ('a : un) => int -> 'a -> 'a t
  val free : ('a : aff) => 'a t -> unit
  val length : &('a t) -> int
  val get : ('a : un) => &('a t) * int -> 'a
  val set : ('a : aff) => &!('a t) * int * 'a -> unit
  val map : (&'a -> 'b) -> &('a t) -> 'b t
end

module Array : ARRAY
\end{lstlisting}
    \vspace{-15pt}
    \caption{Signature}
    \label{sig:array}
  \end{subfigure}

  \begin{subfigure}[t]{1\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get (&a, i-1) + get (&a, i-2) in(*@\label{ex:array:get}*)
    set (&!a, i, x)(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \vspace{-10pt}
    \caption{Example of use}
    \label{ex:array}
\begin{lstlisting}[firstnumber=2]
  let a = create n 1 in
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |} done;
\end{lstlisting}
    \vspace{-10pt}
    \caption{Excerpt of \cref{ex:array} with explicit regions}
    \label{ex:array:region}
  \end{subfigure}
  \vspace{-5pt}
  \caption{Linear arrays}
  \label{ex:array}
\end{figure}

\cref{ex:array:region} uses braces @{| ... |}@ to make the
regions of the example in \cref{ex:array} explicit.  One
region consists of the header expression of the @let@ in
\cref{ex:array:region:get}. It is contained in another region that
comprises the body of the @for@ loop. \lang guarantees that borrows
never escape the smallest enclosing region. It employs a system of
\emph{indexed kinds} like @aff_r@ and @un_r@ where
$r$ is a positive integer that corresponds to the lexical nesting
depth of regions. For instance, the type of @&!a@ in
\cref{ex:array:set} has kind @aff_1@ whereas the type of
@&a@ in \cref{ex:array:region:get} has kind
@un_2@ and the typing of the inner region is such that types with
kind indexes greater than or equal to $2$ cannot escape.
In the example, borrows cannot escape  because they are consumed
immediately by @get@ and @set@.

Region annotations are automatically inserted using
syntactic cues such as borrows and binders (see
\cref{regionannot}).  Users may manually insert regions to further restrict the range of a
borrow. In practice, region annotations are
rarely needed with common programming idioms.
% All regions for the examples in this section have been inferred.


% \begin{figure}
%   \centering
%   % \begin{subfigure}{0.6\linewidth}
% \begin{lstlisting}
% let mk_fib_array n =
%   let a = create n 1 in
%   for i = 2 to n - 1 do {|
%     let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
%     set &!a i x
%   |}
%   done;
%   a(*@\label{ex:array:return}*)
% # mk_fib_array : int -> int Array.t
% \end{lstlisting}
%     \caption{Example from \cref{ex:array} with explicit regions}
%     \label{ex:array:region}
%   % \end{subfigure}
% \end{figure}




\subsection{Solving sudokus with hybrid data-structures}

Recently introduced persistent data structures
permit transient mutations where
non-linear uses lead to degraded performance
\cite{DBLP:conf/ml/ConchonF07} or to
dynamic and static checks \cite{DBLP:journals/pacmpl/Puente17}.
In particular, persistent Hash-Array-Mapped-Tries (HAMT) have been used with similar
APIs in several non-pure functional languages (OCaml, Clojure, \dots).
Affine types help formalize the performance contract between the programmer
and the library, while borrows avoid the need to thread state explicitly,
as usually required by an API for immutable data types.
%

In this section, we present
a safe API for persistent arrays that support both immutable and mutable features,
and use it to implement a backtracking Sudoku solver.
% show how \lang allows us to define
The Sudoku solver maintains an array to represent the state of
the game and uses backtracking when there are several choices to proceed.
The use of backtracking suggests a persistent data structure for the array.
However, only changes that correspond to a choice point need to use
the persistence mechanism, others may be implemented as
cheap in-place mutations.

\cref{sig:hybarray} contains an API @HybArray@
that enables using mutable and immutable modifications to
the board through affine types and borrows.
The signature differs slightly from the @Array@
signature. For simplicity, the array elements are unrestricted, but
the structure itself remains linear so as to be implemented in terms of @Array@.
The in-place mutation function @set_mut@ with type
@&!('a t) * int * 'a -> unit@ works on a exclusive borrow  whereas the persistent
@set@ operation has type @&('a t) * int * 'a -> 'a t@. It
takes a shared borrow because it only reads from the
argument array, but returns a fresh,  modified structure.
The code in \cref{ex:cow} contains a very simple implementation of
@HybArray@ that represents hybrid arrays
as regular arrays and uses copy-on-write for persistent
modifications. The function
@mapi: (int -> &'a -> 'b) -> &('a t) -> 'b t@
is a simple variation on @Array.map@ where the mapping function
takes the position of the element.
% A more elaborate implementation could use persistent arrays
% \cite{DBLP:conf/ml/ConchonF07}.


\begin{figure}[tp]
  \centering
  % \begin{subfigure}{1\linewidth}
\begin{lstlisting}
module type HybArray = sig
  include ARRAY
  val set : &('a t) * int * 'a -> 'a t
  val set_mut : &!('a t) * int * 'a -> unit
end

module Cow : HybArray = struct
  include Array
  let set (a, i0, x0) =
    Array.mapi (fun i x -> if i = i0 then x0 else x) a
  let set_mut = Array.set
end
\end{lstlisting}
    \vspace{-15pt}
  %   \caption{Implementation using copy-on-write}
  % \end{subfigure}
  \caption{Hybrid arrays}
    \label{sig:hybarray}
    \label{ex:cow}
  
  \lstinputlisting[linerange=1-31]{code/sukodu.affe}
    \vspace{-15pt}
  \caption{Excerpt of the Sudoku solver}
  \label{ex:sudoku}
\end{figure}

Our implementation of a Sudoku solver (\cref{ex:sudoku}) performs
modifications that correspond to choice points using @set@,
which makes it trivial to come back to the previous version
of the array, while other modifications use @set_mut@, which
forbids uses of the previous version.

The board is represented as a 2D-matrix (\cref{line:boardtype}), where
the @Matrix@ type uses the same API as @HybArray@
but with two indices.
Each cell contains an integer set that represent admissible solutions so far.
The Sudoku solver iterates over the cells and tries each possible solution (\cref{line:try_solution}).
When a value is picked for the current cell, we create a choice point,
change the cell with an immutable modification (\cref{line:immutset}), and propagate
the changes with the @propagate@ function.
The @propagate@ function uses direct mutation through a
exclusive borrow of the matrix as it need not preserve the previous
version of the board.
The implementation of @propagate@ is split into three parts
for lines, columns, and square, which are all very similar to function
@propagate_lines@ (\cref{line:propline}).

The typing ensures that the mutations do not compromise the state at
the choice point, because they operate on a new state @new_g@ created for one
particular branch of the choice.
As the @set@ function only requires an unrestricted shared borrow,
the closure @try_solution@ remains unrestricted even though
it captures the borrow @&g@. 
The price is that @try_solution@ cannot escape from
@&g@'s region. In this example, inference places the region
around the @begin@/@end@ scope.
Hence, @try_solution@ can be used in
the iteration in \cref{line:iter}.
% As @&g@ is unrestricted, we could even use a parallel iteration
% instead of a sequential one.
As @g@ is linear we must free it outside of the region
before returning (\cref{line:free:g}). 

While presented for copy-on-write arrays, the API
can easily be adapted to other persistent data structures with
transient mutability such as Relaxed-Radix Balance Vectors (RRB) \cite{DBLP:journals/pacmpl/Puente17}
or persistent HAMTs \cite{bagwell2001ideal,clojurehamt} to provide  a
convenient programming style without compromising performance.

% \subsection{Type abstraction and linearity violations}

% While linearity allows to verify many properties, it also prevents
% the implementation of functions that are nevertheless safe. Rust addresses this
% issue through the @unsafe@ construct, which allows to locally
% ignore linearity constraints. This is essential to build basic
% functions such as splitting strings.
% %
% \lang allows to partially emulate this behavior using type abstraction
% as provided by ML modules.
% In particular, data types can be internally defined as unrestricted but exposed
% as affine.

% \TODO{Show example with arrays}

\subsection{Iterators and regions}
\label{tuto:vector}


% We have seen that borrows are limited to a region.
In the examples so far, regions do not appear in type signatures.
But for certain programming idioms, we want to extend the scope of a
region across a function boundary.
For instance, how should we fold on an array of linear objects?
A naive fold function would only work on unrestricted content:
\begin{lstlisting}
val fold : ('a : un) => ('a -> 'b -> 'b) -> 'a array -> 'b -> 'b
\end{lstlisting}

However, if we want to work on linear and affine resources,
we must make sure those resources are not leaked in the result.
content. We obtain the following signature:

\begin{lstlisting}
val fold :
  ('b:'k),('k <= aff_r) =>
  (&(aff_r1,'a) -> 'b -{aff_r}> 'b) -> &('a array) -> 'b -{lin}> 'b
\end{lstlisting}

The folded function receives a shared borrow of the element in the array.
The typing of the callback ensures
that this borrow is neither captured nor returned by the function.
%
This encapsulation is implemented with a universally quantified \emph{kind index variable} $r$.
The signature prescribes the type @&!(aff_r1,'a)@ for the
exclusive borrow of the resource with an affine kind at region nesting $r+1$. The return
type of the callback is constrained to kind @'k <= aff_r@
so that the callback certainly cannot return the borrowed argument.
%
The input of the fold is a shared borrow of the array,
which ensures that we have the right to share borrows of the inner content and
make multiple concurrent folds.

We can then easily use this function to fold over an array of files. Here
we compute the sum of their lengths:

\begin{lstlisting}
let all_lengths = fold (fun f s -> read f + s) &all_files 0 
\end{lstlisting}

Naturally, this is not sufficient if we want to mutate the array during iteration.
For this purpose, we need to take an exclusive borrow of the structure to iterate
on:

\begin{lstlisting}
val iter_mut : &!('a array) -> (&!(aff_r1,'a) -{un_r}> unit) -{lin}> unit
\end{lstlisting}

Here, the callback of the @iter@ function must be of kind @un_r@: Indeed, this
callback should be @un@, as it will be called multiple time, but it should also
be prevented from capturing objects of the region $r+1$ to prevent the borrow
from escaping.

While the distinction between mutable and immutable iteration function
might seem unfortunate, it is typical of
programming with borrows and is also present in the Rust standard library, for
instance. It allows the programmer to explicitly state how various iterations
are allowed to compose and be optimized.
\lang's region variables ensures that the content iterated on can never
be leaked outside of the iteration function.
This pattern is essential in many use-cases of linearity such
as pools of linear objects (see \cref{tuto:pool}). 

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
