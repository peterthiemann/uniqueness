\section{Linearity, Affinity, and Borrows at Work}

\TODO{really good examples. first linearity/affinity (files?), then
  something with borrows (functional arrays), and then something
  really spaced out that pushes the limit}

\subsection{A session on linearity}
\label{sec:session-linearity}

Session typing \cite{Honda1993,DBLP:conf/esop/HondaVK98} is a type
discipline for checking protocols statically. A session type is
ascribed to a communication channel and describes
a sequence of interactions. For instance, the type
\lstinline{!int.!int.?int.end} specifies a protocol
where the program must send two integers, receive an integer, and then
close the channel. 
%
In this context, channels must be used linearly, because every use of
a channel ``consumes'' one interaction and hence changes the type of the
channel. That is, after sending two integers on the channel,
the remaining channel has type \lstinline{?int.end}.

Here are some standard type operators for session types \SType:
\begin{center}
  $\SType ::=$
  \begin{tabular}[t]{rl}
    $\tau ! \SType$ & Send a value of type $\tau$ then continue with protocol $\SType$.\\
    $\tau ? \SType$& Receive a value of type $\tau$ then continue with protocol $\SType$.\\
    $\SType \oplus \SType'$& Internal choice between protocols $\SType$ and $\SType'$.\\
    $\SType \operatorname{\&} \SType'$
                    & Offer a choice between protocols $\SType$ and $\SType'$. 
  \end{tabular}
\end{center}

\citet{DBLP:journals/jfp/Padovani17}  has shown how to encode this
style of session typing in ML-like languages, but his implementation
downgrades linearity to a run-time check for affinity. Building on that
encoding we can provide a safe API in \lang that statically enforces
linear handling of channels:
%
\begin{lstlisting}
type 'S st : lin (*@\label{line:session1}*)
val receive: ('a ? 'S) st -> 'a * 'S st (*@\label{line:session2}*)
val send : ('a ! 'S) st -> 'a -{lin}> 'S st
val create : unit -> 'S st * (dual 'S) st
val close : end st -> unit
\end{lstlisting}
% val send : ('a:'k). 'a -> ('a ! 'S) st -{'k}> 'S st 

Line~\ref{line:session1} introduces a parameterized abstract
type \lstinline{st} which is linear as indicated
by its kind \lstinline{lin}. Its low-level implementation would wrap a
handle for a socket, for example. The \lstinline{receive}  operation
in Line~\ref{line:session2} takes a channel that is ready to receive a
value of type \lstinline{'a} and returns a pair of the value a the
channel at its residual type \lstinline{'S}. It does not matter
whether \lstinline{'a} is restricted to be linear, in fact
\lstinline{receive} is polymorphic in the kind of \lstinline{'a} and
also in the kind of \lstinline{->}. This kind polymorphism is the
default if no constraints are specified.
%
The \lstinline{send} operation takes a linear channel and returns a
single-use function that takes a value of type \lstinline{'a} suitable
for sending and returns the channel with updated type.
%
The \lstinline{create} operation returns a pair of channel
endpoints. They follow dual communication protocols, where the
\lstinline{dual} operator swaps sending and receiving operations.
%
Finally, \lstinline{close} closes the channel.

In \cref{fig:sessiontype} we show how to use these primitives to
implement client and server for an addition service.
No linearity annotations are needed in the code, as all linearity
properties can be inferred from the linearity of the \texttt{st} type.

The inferred type of the server, \lstinline{add_service}, is
\lstinline{(int ! int ! int ? end) st -> unit}.
The client operates by sending two messages
and receiving the result.
This code is polymorphic in both argument and return types, so it could
be used with any binary operator.
%
\begin{figure}[!h]
  \begin{subfigure}[t]{.5\linewidth}
\begin{lstlisting}
let add_service ep =
  let x, ep = receive ep in
  let y, ep = receive ep in
  let ep = send ep (x + y) in
  close ep
# add_service :
  (int ! int ! int ? end) st -> unit
\end{lstlisting}
    \caption{Addition server}
  \end{subfigure}~
  \begin{subfigure}[t]{.5\linewidth}
\begin{lstlisting}
let op_client ep x y =
  let ep = send ep x in
  let ep = send ep y in
  let result, ep = receive ep in
  close ep;
  result
# op_client :
  ('a_1 ? 'a_2 ? 'b ! end) st -> 'a_1 -{lin}> 'a_2 -{lin}> 'b
\end{lstlisting}
% The actual answer from the typechecker looks like this:
% # ('m2:^k2), ('m1:^k1).
% # (^k1 < ^k) & (lin < ^k) =>
% # ('m1 ?'m2 ? 'result ! end) st -> 'm1 -{lin}> 'm2 -{^k}> 'result
    \caption{Binary operators client}
  \end{subfigure}
  \caption{Corresponding session type programs in \lang}
  \label{fig:sessiontype}
\end{figure}
%
Moreover, the \lstinline/op_client/ function can be partially applied
to a channel. Since the closure returned by such a partial application
captures the channel, it can only be used once.  This restriction is
reflected by the arrow of kind \lstinline{lin}, \lstinline/-{lin}>/,
which is the type of a single-use function. 
The general form of
arrows types in \lang is \lstinline/-{k}>/, where \lstinline/kk/ is a
kind that restricts the number of uses of the function.  For
convenience, we shorten \lstinline/-{un}>/ to \lstinline/->/.  \lang
infers the
single-use property of the arrows without any user
annotation. In fact, the only difference between the
code presented here and Padovani's examples
\cite{DBLP:journals/jfp/Padovani17} is the kind annotation on the
type definition of \lstinline/st/.

To run client and server, we can create a channel and apply
\lstinline{add_service} to one end and \lstinline{op_client} to the other.
Failure to consume either channel endpoints (\lstinline/a/ or \lstinline/b/)
would result in a type error.
\begin{lstlisting}
let main () =
  let (a, b) = create () in
  fork add_service a;
  op_client b 1 2
# main : unit -> int
\end{lstlisting}


% \begin{figure}
%   \centering
%   \begin{lstlisting}
% val select : ('S st -{'k}> 'a) -> 'a ot -{'k}> ('S dual) st
% val branch : 'm it -> 'm
%   \end{lstlisting}
%   \caption{Session primitives}
%   \label{api:session}
% \end{figure}

\subsection{Imperative programming}
\label{sec:imper-progr}

The functional resource-passing style demonstrated for channels in
\cref{sec:session-linearity} becomes tedious when manipulating mutable
resources like buffers or connection pools.
%
To make linearity easier to use with an imperative programming style, we rely on
the notion of borrowing \cite{DBLP:conf/popl/BoylandR05}.

As a first example, we consider an API for mutable linear arrays
(\cref{sig:array}).
The intention of this API is to safely handle manual allocation and
deallocation of arrays that may contain affine elements.
One would first use \lstinline/create n v/ to create
an (unrestricted) array of size \lstinline/n/ with some value
\lstinline/v/. This value must be unrestricted as it is duplicated to
initialize all array elements. Using the \lstinline/map/ function we
can transform the unrestricted elements into linear (affine)
ones. This array can be processed further using \lstinline/map/ (or \lstinline/set/ if
affine). The \lstinline/get/ function only applies if the element type
is unrestricted as one element is duplicated. The \lstinline/length/
function applies anytime. Before \lstinline/free/ing the array the elements must be
affine, again. 

To manage the different kinds of accessing the array we distinguish between constructors, destructors, 
observers, and mutators. 
Constructors and destructors like \lstinline/create/ and \lstinline/free/ manipulate the whole
array. As with channels in \cref{sec:session-linearity},
\lstinline/create/ yields a linear resource which is consumed by \lstinline/free/.
During the lifetime of the array resource \lstinline/a/, we can split
off \emph{immutable borrows} \lstinline/&a/ that provide a read-only
view or \emph{mutable borrows} \lstinline/&!a/ for read-write views.
Observer functions such as \lstinline/length/ and \lstinline/get/ expect an immutable borrow
argument, mutator functions such a \lstinline/set/ expect
a mutable borrow.

Each borrow is tied to a region whose lifetime is properly
contained in the lifetime of the resource. 
In a region, we can split off as many immutable borrows as we like
from a resource, but we can take only one mutable borrow. In a
subsidiary region, we can take further immutable borrows from any
borrow or we can take a mutable borrow from a mutable borrow from a
enclosing region. Borrows are confined to their regions. Inside the region,
immutable borrows are unrestricted (\lstinline/un/) whereas mutable
borrows are affine (\lstinline/aff/).

The code in \cref{ex:array} demonstrates a use of the API to create an
array of Fibonacci numbers. After creation of the array, we can see
that the presence of a borrow prevents access to the ``raw'' 
resource inside the borrow's region. In \cref{ex:array:get} of the
example, there are two immutable borrows in the same
expression, which forms a region by itself. These borrows are split
off the mutable borrow used in \cref{ex:array:set}, which belongs to
the next enclosing region.
Finally, the code returns the whole array in \cref{ex:array:return},
which is possible because none of the borrows are in scope anymore.

\begin{figure}[tp]
  \centering
  \begin{subfigure}{0.48\linewidth}
\begin{lstlisting}
module Array : sig
  type ('a : 'k) t : lin
  
  val create : ('a : un) => int -> 'a -> 'a t
  val free : ('a : aff) => 'a t -> unit

  val length : &('a t) -> int

  val get : ('a : un) => &('a t) * int -> 'a
  val set : ('a : aff) => &!('a t) * int * 'a -> unit
  
  val map : (&'a -> 'b) -> &('a t) -> 'b t
end
\end{lstlisting}
    \caption{Affine arrays}
    \label{sig:array}
  \end{subfigure}\hfill
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get (&a, i-1) + get (&a, i-2) in(*@\label{ex:array:get}*)
    set (&!a, i, x)(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \caption{Example of use of affine arrays}
    \label{ex:array}
  \end{subfigure}
\end{figure}

\cref{ex:array:region} makes explicit the regions from the example
indicated by braces as in \lstinline/{| ... |}/.  \lang guarantees that borrows
never escape the smallest enclosing region.  For instance, in
\cref{ex:array:region:get}, \lstinline/&a/ does not escape because it
is consumed in the calls to \lstinline/get/.
Regions annotations are automatically inserted using
syntactic information such as borrows and binders (see
\cref{regionannot} for more information).  Users can also
annotate regions manually to further restrict the range of a
borrow. In practice, we have found that region annotations are
rarely needed with common programming idioms. All regions for the
examples in this section have been inferred.


\begin{figure}
  \centering
  % \begin{subfigure}{0.6\linewidth}
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |}
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}
    \caption{Example from \cref{ex:array} with explicit regions}
    \label{ex:array:region}
  % \end{subfigure}
\end{figure}



\begin{figure}
  \centering
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
let for f a  = 
  let n = Array.length &a in
  let rec loop f a i = 
    if i < n then (
      f &!a i;
      loop f &!a (i+1)
    )
  in
  loop f &!a 0
# for : Borrowed m ('a Array.t) tt =>
  (tt -> int -> unit) -> tt -> unit
\end{lstlisting}
    \caption{For loop function for affine arrays}
    \label{ex:array:for}
  \end{subfigure}
\end{figure}

\subsection{Hybrid programming style}

In the last few years, new persistent data structures
have been introduced which permit transient mutations, but discourage
non-linear uses either through degraded performance
\cite{DBLP:conf/ml/ConchonF07} or
dynamic and static checks \cite{DBLP:journals/pacmpl/Puente17}.
In particular, persistent Hash-Array-Mapped-Tries have been used with similar
APIs in several non-pure functional languages (OCaml, Clojure, \dots).
Affine types allow us to formalize the performance contract between the programmer
and the library, while borrows avoid the need to thread state explicitly,
as usually required by an API that enforces immutability.
%
In this section, we show how \lang allows us to define
a safe API for persistent arrays that support both immutable and mutable features,
and how it can be used to implement a simple backtracking Sudoku solver.

The Sudoku solver maintains a 2D-array that represents the state of
the game and uses backtracking when there are several alternatives to proceed.
The use of backtracking suggests a persistent data structure for the 2D-array.
However, only changes that correspond to a choice point need to use
the persistence mechanism, others may be implemented as
cheap in-place mutations.

\cref{sig:hybarray} contains an API \lstinline/HybArray/ 
that guarantees correct use of mutable and immutable modifications to
the board by relying on affine types and borrows.
The signature differs slightly from the \lstinline/Array/
signature. For simplicity, the array elements are unrestricted, 
hence it is sufficent for the array to be affine.
The in-place mutation function is called \lstinline/set_mut/ with type
\lstinline/&!('a t) * int * 'a -> unit/ and the persistent
\lstinline/set/ operation has type \lstinline/&('a t) * int * 'a -> 'a t/. It
takes an \emph{immutable borrow} because it only reads from the
argument array, but returns a fresh,  modified structure.
The code in \cref{ex:cow} is a very simple implementation of
\lstinline/HybArray/ that represents hybrid arrays
as regular arrays with copy-on-write for persistent
modifications. The function
\lstinline/create_from : int -> (int -> 'a) -> 'a Array.t /
initializes an array from a function.
% A more elaborate implementation could use persistent arrays
% \cite{DBLP:conf/ml/ConchonF07}.


\begin{figure}[tp]
  \centering
  \begin{subfigure}{0.48\linewidth}
\begin{lstlisting}
module type HybArray = sig
  type ('a : un) t : aff
  
  val create : int -> 'a -> 'a t
  val free : 'a t -> unit

  val length : &('a t) -> int
  val get : &('a t) * int -> 'a

  val set : &('a t) * int * 'a -> 'a t
  val set_mut : &!('a t) * int * 'a -> unit
end
\end{lstlisting}
    \caption{Signature}
    \label{sig:hybarray}
  \end{subfigure}\hfill
  \begin{subfigure}{0.5\linewidth}
\begin{lstlisting}
module Cow : HybArray = struct
  include Array

  let set (a, i, x) =
    let f k =
      if k = i then x else get (a,k)
    in
    create_from (length a) f
  
  let set_mut = Array.set
end
\end{lstlisting}
    \caption{Implementation using copy-on-write}
    \label{ex:cow}
  \end{subfigure}
  \caption{Hybrid arrays -- signature and example implementation}
\end{figure}



Thanks to this API, modifications that correspond to backtracking points
use \lstinline/set/, which allows arbitrary uses of the previous version
of the array, while other modifications uses \lstinline/set_mut/, which
forbids uses of the previous version.
This can be seen in the Sudoku solver implementation in \cref{ex:sudoku}.
The board is represented as a matrix of cells (\cref{line:boardtype}).
We assume the existence of a \lstinline/Matrix/ module which uses the same API
as \lstinline/HybArray/ but with two indices.
Each cell is an integer
set that represent admissible solutions so far. The Sudoku solver will
iterate on the cells and try each possible solution (\cref{line:try_solution}).
When a value is picked for the current cell, we use an immutable modification
to create a backtracking point (\cref{line:immutset}) and propagate
the changes with the \lstinline/propagate/ function. The \lstinline/propagate/
function does not need to preserve the previous
version of the board, and thus uses direct mutation.
The implementation of \lstinline/propagate/ is split into three parts
for lines, columns, and square. For concision, only \lstinline/propagate_lines/ is
presented here (\cref{line:propline}).
The typing ensures that all the mutations do not compromise
backtracking, since sharing is only allowed through
the immutable set functions, which is used for backtracking points.
In particular, the \lstinline/try_solution/ function can be used in a loop
precisely because the \lstinline/set/ function only requires an
\emph{immutable} borrow of \lstinline/new_g/.
This is allowed, since immutable borrows are unrestricted.

While we presented our API on simple copy-on-write arrays, this API
could easily be adapted to any persistent data-structure with
transient mutability such as RRB Vectors \cite{DBLP:journals/pacmpl/Puente17}
and persistent HAMT (used notably as Clojure's default associative maps
\cite{bagwell2001ideal,clojurehamt}) while providing a good performance profile
and a convenient programming style.

\begin{figure}
  \centering
  \begin{minipage}[t]{0.45\linewidth}
    \lstinputlisting[linerange=1-13]{code/sukodu.affe}
  \end{minipage}\hfill
  \begin{minipage}[t]{0.54\linewidth}
    \lstinputlisting[linerange=15-28,firstnumber=last]{code/sukodu.affe}
  \end{minipage}
  \caption{Excerpt of the Sudoku solver}
  \label{ex:sudoku}
\end{figure}

% \subsection{Type abstraction and linearity violations}

% While linearity allows to verify many properties, it also prevents
% the implementation of functions that are nevertheless safe. Rust addresses this
% issue through the \lstinline/unsafe/ construct, which allows to locally
% ignore linearity constraints. This is essential to build basic
% functions such as splitting strings.
% %
% \lang allows to partially emulate this behavior using type abstraction
% as provided by ML modules.
% In particular, data types can be internally defined as unrestricted but exposed
% as affine.

% \TODO{Show example with arrays}

\subsection{Local data-structures with regions}
\label{tuto:pool}

We have seen that borrows are limited to a region. In the various examples so
far, such regions didn't appear in the type signatures explicitly.
We know present an pool implementation which can store linear objects
and such region to enforce proper uses of the objects.
The implementation and interfaces of the \texttt{Pool} module
are shown in \cref{impl:pool,intf:pool}. A simple example of use
is shown in \cref{ex:pool}. 

A pool is parameterized by its content. The kind of the pool
depends on the content: linear content implies
a linear pool while unrestricted content implies an unrestricted pool.
The functions \lstinline/Pool.create/ and \lstinline/Pool.consume/ allow
to build or destroy
the pool by providing the corresponding functions for the elements
of the pool.
The main function is \lstinline/Pool.use/ which
allow to use an object from the pool.
\lstinline/Pool.use/ takes a shared borrow of a pool (in order to allow
for concurrent access) and a function. This function will receive
a mutable borrow of one arbitrary object of the pool. The typing ensure
that this borrow is not captured nor kept by the function.
This is done through a \emph{region} variable $r$ which annotates
the kinds. Here, the borrow is of type \lstinline/&!(aff_r,'a_1 )/, which indicates
a mutable borrow with an affine kind. The return type of \lstinline/f/ is bound
to be of kind \lstinline/'k_2 < aff_r/. Since this is a strict inequality,
types whose kind mention the region can not be returned.

The implementation presented in \cref{impl:pool} uses a concurrent queue
as a bag of elements with atomic add and remove operations.
The implementation for the \lstinline/Pool.create/ and \lstinline/Pool.consume/
functions are straightforward.
The function \lstinline/Pool.use/ first draws
an element from the pool (or creates a fresh element),
pass it down to the \lstinline/f/ function, and then add
it back to the pool.
We explicitly delimit the region on \cref{line:pool:region} to ensure that
the return value of \lstinline/f &!o/ do not capture \lstinline/&!o/.

\begin{figure}[!h]
  \centering
  \begin{subfigure}[t]{.45\linewidth}
\begin{lstlisting}
type ('a:'k) pool : 'k = {
  spawn : unit -> 'a ;
  queue : 'a CQueue.t;
}

let create spawn =
  { spawn ; queue = CQueue.create () }
let consume f c = CQueue.iter f c.queue

let use { spawn ; queue } f =
  let o = match CQueue.pop &queue with
    | Some x -> x
    | None () -> spawn ()
  in
  let r = {| f &!o |} in(*@\label{line:pool:region}*)
  Queue.push o &queue;
  r
\end{lstlisting}
    \caption{Implementation}
    \label{impl:pool}
  \end{subfigure}~
  \begin{subfigure}[t]{.55\linewidth}
\begin{lstlisting}
type ('a:'k) pool : 'k

create : (unit -> 'a) -> 'a pool
consume : ('a -> unit) -> 'a pool -> unit
use : ('a_1:'k_1),('a_2:'k_2),('k_1 < aff_r),('k_2 < aff_r) =>
  &('a_1 pool) -> (&!(aff_r,'a_1) -{lin}> 'a_2) -{'k_1}> 'a_2
\end{lstlisting}
    \caption{Interface}
    \label{intf:pool}

\begin{lstlisting}
let uri = "postgresql://localhost:5432"

(* Create a database connection pool. *)
let pool = Pool.create (fun () -> Db.connect uri)

(* Use the pool in queries. *)
let create_user name =
  Pool.use &pool (fun connection ->
    Db.insert "users" [("name", name)] connection)
\end{lstlisting}
    \caption{Example of use}
    \label{ex:pool}
  \end{subfigure}

  \caption{The \texttt{Pool} module}
  \label{fig:pool}
\end{figure}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
