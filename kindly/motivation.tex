\section{Linearity, Affinity, and Borrows at Work}
\label{motivation}

\lstMakeShortInline[keepspaces,basicstyle=\small\ttfamily]@

\lang{} is amenable to a functional resource-passing style
common in functional encodings of session types (e.g.,
\cite{DBLP:journals/jfp/Padovani17}; see also
\cref{sec:session-linearity} in the supplement). But it really shines
when manipulating mutable resources like buffers or connection pools
using a mixed functional and imperative programming style.
%
To support this usage pattern of linearity, we rely on
the notion of borrowing \cite{DBLP:conf/popl/BoylandR05} which
we demonstrate through a series of examples.

As running theme of our examples, we use an API for persistent arrays.
Recently introduced persistent data structures
permit transient mutations where
non-linear uses lead to degraded performance
\cite{DBLP:conf/ml/ConchonF07} or to
dynamic and static checks \cite{DBLP:journals/pacmpl/Puente17}.
In particular, persistent Hash-Array-Mapped-Tries (HAMT) have been used with similar
APIs in several non-pure functional languages (OCaml, Clojure, \dots).
Affine types help formalize the performance contract between the programmer
and the library, while borrows avoid the need to thread state explicitly,
as usually required by an API for immutable data types.

\cref{sig:hybarray} contains an API @PersistArray@
that enables using mutable and immutable modifications to
the board through affine types and borrows.
%
We first present how to use it imperatively, as if it was a simple
mutable linear array. We then see how to exploit its persistent
properties to write a backtracking sudoku solver. Finally, we consider
iterators on such linear structures.

% \begin{itemize}
% \item An API for linear arrays to demonstrate simple borrowing and imperative programming.
% \item
%   A backtracking Sudoku solver to demonstrate
%   \lang's ability to build safe hybrid functional/imperative data-structures.
% \item A pool of linear objects to demonstrate advanced use of regions.
% \end{itemize}

\begin{figure}[tp]
  \centering
  % \begin{subfigure}{1\linewidth}
\begin{lstlisting}
module PersistArray : sig
  type ('a : 'k) t : lin
  val create : ('a : un) => int -> 'a -> 'a t
  val free : ('a : aff) => 'a t -> unit
  val length : &('a t) -> int
  val get : ('a : un) => &('a t) * int -> 'a
  val set_mut : ('a : aff) => &!('a t) * int * 'a -> unit
  val set : ('a : un) => &('a t) * int * 'a -> 'a t
  val map : (&'a -> 'b) -> &('a t) -> 'b t
end
\end{lstlisting}
% \begin{lstlisting}
% (* A copy-on-write implementation *)
% module Cow : PersistArray = struct
%   type 'a t = 'a array
%   ...
%   let set (a, i0, x0) =
%     mapi (fun i x -> if i = i0 then x0 else x) a
% end
% \end{lstlisting}
  \vspace{-15pt}
  % \caption{Implementation using copy-on-write}
  % \end{subfigure}
  \caption{Hybrid arrays}
  \label{sig:array}
  \label{sig:hybarray}
  \label{ex:cow}
\end{figure}

\subsection{Imperative programming}

Our API for linear arrays
aims to safely handle manual allocation and
deallocation of arrays that may contain affine elements.
One would first use @create n v@ to create
an (unrestricted) array of size @n@ initialized with value
@v@. This value must be unrestricted as it is duplicated to
initialize all array elements. Using the @map@ function we
can transform the unrestricted elements into linear (affine)
ones. This array can be processed further using @map@ (or @set_mut@ if
affine). The @get@ and @set@ function are only applicable if the element type
is unrestricted as one element is duplicated. The @length@
function is always applicable. To @free@ an array the elements must be
affine.

To manage the different kinds of accessing the array we distinguish between constructors, destructors,
observers, and mutators.
Constructors and destructors like @create@ and @free@ manipulate the whole
array. %As with channels in \cref{sec:session-linearity},
The constructor
@create@ yields a linear resource which is consumed by @free@.
During the lifetime of the array resource @a@, we can split
off \emph{shared borrows} @&a@ that provide a read-only
view or \emph{exclusive borrows} @&!a@ for read-write views.
Observer functions such as @length@, @get@ and @set@ expect a shared borrow
argument, mutator functions such a @set_mut@ expect
a exclusive borrow.

Each borrow is tied to a region whose lifetime is properly
contained in the lifetime of the resource.
In a region, we can split off as many shared borrows of a resource as
we like, but we can take only one exclusive borrow. In a
subsidiary region, we can take shared borrows of any
borrow or we can take an exclusive borrow of an exclusive borrow from an
enclosing region. Borrows are confined to their regions. Inside the region,
shared borrows are unrestricted (@un@) whereas exclusive
borrows are affine (@aff@).

We can use these arrays in a purely mutable fashion
to create an
array of Fibonacci numbers using code very similar to an usual imperative style:
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get (&a, i-1) + get (&a, i-2) in(*@\label{ex:array:get}*)
    set_mut (&!a, i, x)(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}

After
creation of the array, the presence of a borrow in the for loop
prevents access to the ``raw'' resource inside the loop's
body. \cref{ex:array:get} of the example contains two shared borrows
in the same expression, which forms a region by itself. These borrows
are split off the exclusive borrow used in \cref{ex:array:set}, which
belongs to the next enclosing region corresponding to the loop body.
The whole array can be returned in \cref{ex:array:return} because  the
borrows are no longer in scope. 

More precisely, the code below is an annotated excerpt with explicit regions
marked in braces @{| ... |}@:

\begin{lstlisting}[firstnumber=3]
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |} done;
\end{lstlisting}

One
region consists of the header expression of the @let@ in
\cref{ex:array:region:get}. It is contained in another region that
comprises the body of the @for@ loop. \lang guarantees that borrows
never escape the smallest enclosing region. It employs a system of
\emph{indexed kinds} like @aff_r@ and @un_r@ where
$r$ is a positive integer that corresponds to the lexical nesting
depth of regions. For instance, the type of @&!a@ in
\cref{ex:array:set} has kind @aff_1@ whereas the type of
@&a@ in \cref{ex:array:region:get} has kind
@un_2@ and the typing of the inner region is such that types with
kind indexes greater than or equal to $2$ cannot escape.
In the example, borrows cannot escape  because they are consumed
immediately by @get@ and @set_mut@.

\subsection{Solving sudokus with hybrid data-structures}

\begin{figure}[tp]
  \lstinputlisting[linerange=1-31]{code/sukodu.affe}
  \vspace{-15pt}
  \caption{Excerpt of the Sudoku solver}
  \label{ex:sudoku}
\end{figure}

On top of the mutation function @set_mut@, our array implementation
also provides @set@ of type @&('a t) * int * 'a -> 'a t@. It
takes a shared borrow because it only reads from the
argument array, but returns a fresh, modified structure.
%
This API could be implemented in a wide variety of ways, such as
copy-on-write (which copies the whole array on each @set_mut@)
or something more sophisticated\cite{DBLP:conf/ml/ConchonF07}.

We can use our persistent arrays
to implement a backtracking Sudoku solver.
% show how \lang allows us to define
The Sudoku solver maintains an array to represent the state of
the game and uses backtracking when there are several choices to proceed.
The use of backtracking suggests a persistent data structure for the array.
However, only changes that correspond to a choice point need to use
the persistence mechanism, others may be implemented as
cheap in-place mutations.

Our implementation of a Sudoku solver (\cref{ex:sudoku}) performs
modifications that correspond to choice points using @set@,
which makes it trivial to come back to the previous version
of the array, while other modifications use @set_mut@, which
forbids uses of the previous version.

The board is represented as a 2D-matrix (\cref{line:boardtype}), where
the @Matrix@ type uses the same API as @HybArray@
but with two indices.
Each cell contains an integer set that represent admissible solutions so far.
The Sudoku solver iterates over the cells and tries each possible solution (\cref{line:try_solution}).
When a value is picked for the current cell, we create a choice point,
change the cell with an immutable modification (\cref{line:immutset}), and propagate
the changes with the @propagate@ function.
The @propagate@ function uses direct mutation through a
exclusive borrow of the matrix as it need not preserve the previous
version of the board.
The implementation of @propagate@ is split into three parts
for lines, columns, and square, which are all very similar to function
@propagate_lines@ (\cref{line:propline}).

The typing ensures that the mutations do not compromise the state at
the choice point, because they operate on a new state @new_g@ created for one
particular branch of the choice.
As the @set@ function only requires an unrestricted shared borrow,
the closure @try_solution@ remains unrestricted even though
it captures the borrow @&g@.
The price is that @try_solution@ cannot escape from
@&g@'s region. In this example, inference places the region
around the @begin@/@end@ scope.
Hence, @try_solution@ can be used in
the iteration in \cref{line:iter}.
% As @&g@ is unrestricted, we could even use a parallel iteration
% instead of a sequential one.
As @g@ is linear we must free it outside of the region
before returning (\cref{line:free:g}).

While presented for persistent arrays, this API
can easily be adapted to other persistent data structures with
transient mutability such as Relaxed-Radix Balance Vectors (RRB) \cite{DBLP:journals/pacmpl/Puente17}
or persistent HAMTs \cite{bagwell2001ideal,clojurehamt} to provide  a
convenient programming style without compromising performance.

% \subsection{Type abstraction and linearity violations}

% While linearity allows to verify many properties, it also prevents
% the implementation of functions that are nevertheless safe. Rust addresses this
% issue through the @unsafe@ construct, which allows to locally
% ignore linearity constraints. This is essential to build basic
% functions such as splitting strings.
% %
% \lang allows to partially emulate this behavior using type abstraction
% as provided by ML modules.
% In particular, data types can be internally defined as unrestricted but exposed
% as affine.

% \TODO{Show example with arrays}

\subsection{Iterators and regions}
\label{tuto:vector}

% We have seen that borrows are limited to a region.
In the examples so far, regions do not appear in type signatures.
But for certain programming idioms, we want to extend the scope of a
region across a function boundary.
For instance, how should we fold on an array of linear objects?
A naive fold function would only work on unrestricted content:
\begin{lstlisting}
val fold : ('a : un) => ('a -> 'b -> 'b) -> 'a array -> 'b -> 'b
\end{lstlisting}

However, if we want to work on linear and affine resources,
we must make sure those resources are not leaked in the result.
We obtain the following signature:
\begin{lstlisting}
val fold :
  ('b:'k),('k <= aff_r) =>
  (&(aff_r1,'a) -> 'b -{aff_r1}> 'b) -> &('k_1,'a array) -> 'b -{'k_1}> 'b
\end{lstlisting}

The folded function receives a shared borrow of the element in the array.
The typing of the callback ensures
that this borrow is neither captured nor returned by the function.
%
This encapsulation is implemented with a universally quantified \emph{kind index variable} $r$.
The signature prescribes the type @&(aff_r1,'a)@ for the
shared borrow of the resource with an affine kind at region nesting $r+1$. The return
type of the callback is constrained to kind @'k <= aff_r@
so that the callback certainly cannot return the borrowed argument.
%
The input of the fold is a shared borrow of the array,
which ensures that we have the right to share borrows of the inner content and
make multiple concurrent folds.

We can then easily use this function to fold over an array of files. Here
we compute the sum of their sizes:
\begin{lstlisting}
let total_size = fold (fun f s -> File.size f + s) &all_files 0
\end{lstlisting}

Naturally, this is not sufficient if we want to mutate the array during iteration,
as is often the case with @iter@ functions.
For this purpose, we need to take an exclusive borrow of the structure to iterate
on:
\begin{lstlisting}
val iter : &!('a array) -> (&!(aff_r1,'a) -{un}> unit) -{aff}> unit
\end{lstlisting}

While the distinction between mutable and immutable iteration functions
might seem unfortunate, it is typical of
programming with borrows and is also present in the Rust standard library.
It allows the programmer to explicitly state how various iterations
are allowed to compose and be optimized.
\lang's region variables ensures that the content iterated on can never
be leaked outside of the iteration function.
This pattern is essential in many use-cases of linearity such
as pools of linear objects (see example in \cref{tuto:pool}).

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
