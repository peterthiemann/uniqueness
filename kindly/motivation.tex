\section{Linearity, Affinity, and Borrows at Work}
\label{motivation}

\lstMakeShortInline[keepspaces,basicstyle=\small\ttfamily]@

\lang{} is amenable to a functional resource-passing style
common in functional encodings of session types (e.g.,
\cite{DBLP:journals/jfp/Padovani17}; see also
\cref{sec:session-linearity} in the supplement). But it really shines
when manipulating mutable resources like buffers or connection pools
using a mixed functional and imperative programming style.
%
To support this usage pattern of linearity, we rely on
the notion of borrowing \cite{DBLP:conf/popl/BoylandR05} which
we demonstrate first through the example of linear arrays to demonstrate
simple borrowing and imperative programming and second with iterators
on linear values to demonstrate advanced uses of regions.
Further examples are also available in \cref{sec:extra-example}.

\subsection{Imperative programming with linear arrays}
\label{sec:imper-progr}

\begin{figure}[tp]
  \centering
\begin{lstlisting}
module Array : sig
  type ('a : 'k) t : lin
  val create : ('a : un) => int -> 'a -> 'a t
  val free : ('a : aff) => 'a t -> unit
  val length : &('a t) -> int
  val get : ('a : un) => &('a t) * int -> 'a
  val set : ('a : aff) => &!('a t) * int * 'a -> unit
  val map : (&'a -> 'b) -> &('a t) -> 'b t
end
\end{lstlisting}
  \vspace{-15pt}
  \caption{Linear arrays}
  \label{ex:array}
  \label{sig:array}
  \vspace{-10pt}
\end{figure}

The API for mutable linear arrays (shown in \cref{sig:array})
aims to safely handle manual allocation and
deallocation of arrays that may contain affine elements.
One would first use @create n v@ to create
an (unrestricted) array of size @n@ initialized with value
@v@. This value must be unrestricted as it is duplicated to
initialize all array elements. Using the @map@ function we
can transform the unrestricted elements into linear (affine)
ones. This array can be processed further using @map@ (or @set@ if
affine). The @get@ function is only applicable if the element type
is unrestricted as one element is duplicated. The @length@
function is always applicable. To @free@ an array the elements must be
affine.

To manage the different kinds of accessing the array we distinguish between constructors, destructors,
observers, and mutators.
Constructors and destructors like @create@ and @free@ manipulate the whole
array. %As with channels in \cref{sec:session-linearity},
The constructor
@create@ yields a linear resource which is consumed by @free@.
During the lifetime of the array resource @a@, we can split
off \emph{shared borrows} @&a@ that provide a read-only
view or \emph{exclusive borrows} @&!a@ for read-write views.
Observer functions such as @length@ and @get@ expect an shared borrow
argument, mutator functions such a @set@ expect
an exclusive borrow.

Each borrow is tied to a region whose lifetime is properly
contained in the lifetime of the resource.
In a region, we can split off as many shared borrows of a resource as
we like, but we can take only one exclusive borrow. In a
subsidiary region, we can take shared borrows of any
borrow or we can take an exclusive borrow of an exclusive borrow from an
enclosing region. Borrows are confined to their regions. Inside the region,
shared borrows are unrestricted (@un@) whereas exclusive
borrows are affine (@aff@).

We can use the API in a mutable fashion
to create an
array of Fibonacci numbers though an imperative coding style:
\begin{lstlisting}
let mk_fib_array n =
  let a = create n 1 in
  for i = 2 to n - 1 do
    let x = get (&a, i-1) + get (&a, i-2) in(*@\label{ex:array:get}*)
    set_mut (&!a, i, x)(*@\label{ex:array:set}*)
  done;
  a(*@\label{ex:array:return}*)
# mk_fib_array : int -> int Array.t
\end{lstlisting}

After
creation of the array, the presence of a borrow in the for loop
prevents access to the ``raw'' resource inside the loop's
body. \cref{ex:array:get} of the example contains two shared borrows
in the same expression, which forms a region by itself. These borrows
are split off the exclusive borrow used in \cref{ex:array:set}, which
belongs to the next enclosing region corresponding to the loop body.
The whole array can be returned in \cref{ex:array:return} because  the
borrows are no longer in scope.
%
More precisely, here is is an annotated excerpt with explicit regions
marked in braces @{| ... |}@:
\begin{lstlisting}[firstnumber=3]
  for i = 2 to n - 1 do {|
    let x = {| get &a (i-1) + get &a (i-2) |} in(*@\label{ex:array:region:get}*)
    set &!a i x
  |} done;
\end{lstlisting}

A region consists of the header expression of the @let@ in
\cref{ex:array:region:get}. It is contained in another region
spanning the body of the @for@ loop. \lang guarantees that borrows
never escape the smallest enclosing region. It employs a system of
\emph{indexed kinds} like @aff_r@ and @un_r@ where
$r$ is a positive integer that corresponds to the lexical nesting
depth of regions. For instance, the type of @&!a@ in
\cref{ex:array:set} has kind @aff_1@ whereas the type of
@&a@ in \cref{ex:array:region:get} has kind
@un_2@ and the typing of the inner region is such that types with
kind indexes greater than or equal to $2$ cannot escape.
In the example, borrows cannot escape  because they are consumed
immediately by @get@ and @set@.


\subsection{Iterators and regions}
\label{tuto:vector}

% We have seen that borrows are limited to a region.
In the examples so far, regions do not appear in type signatures.
But for certain programming idioms, we want to extend the scope of a
region across a function boundary.
For instance, how should we fold on an array of linear objects?
A naive fold function would only work on unrestricted content:
\begin{lstlisting}
val fold : ('a : un) => ('a -> 'b -> 'b) -> 'a array -> 'b -> 'b
\end{lstlisting}

However, if we want to work on linear and affine resources,
we must make sure those resources are not leaked in the result.
content. We obtain the following signature:
\begin{lstlisting}
val fold :
  ('b:'k),('k <= aff_r) =>
  (&(aff_r1,'a) -> 'b -{aff_r1}> 'b) -> &('k_1,'a array) -> 'b -{'k_1}> 'b
\end{lstlisting}

The folded function receives a shared borrow of the element in the array.
The typing of the callback ensures
that this borrow is neither captured nor returned by the function.
%
This encapsulation is implemented with a universally quantified \emph{kind index variable} $r$.
The signature prescribes the type @&(aff_r1,'a)@ for the
shared borrow of the resource with an affine kind at region nesting $r+1$. The return
type of the callback is constrained to kind @'k <= aff_r@
so that the callback certainly cannot return the borrowed argument.
%
The input of the fold is a shared borrow of the array,
which ensures that we have the right to share borrows of the inner content and
make multiple concurrent folds.

We can then easily use this function to fold over an array of files. Here
we compute the sum of their sizes:
\begin{lstlisting}
let total_size = fold (fun f s -> File.size f + s) &all_files 0
\end{lstlisting}

Naturally, this is not sufficient if we want to mutate the array during iteration.
For this purpose, we need to take an exclusive borrow of the structure to iterate
on:
\begin{lstlisting}
val iter_mut : &!('a array) -> (&!(aff_r1,'a) -{un}> unit) -{aff}> unit
\end{lstlisting}

Since the callback will be called multiple times, it is explicitly
annotated with @un@.

While the distinction between mutable and immutable iteration function
might seem unfortunate, it is typical of
programming with borrows and is also present in the Rust standard library.
It allows the programmer to explicitly state how various iterations
are allowed to compose and be optimized.
\lang's region variables ensures that the content iterated on can never
be leaked outside of the iteration function.
This pattern is essential in many use-cases of linearity such
as pools of linear objects (see \cref{tuto:pool}).

\lstDeleteShortInline@

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
